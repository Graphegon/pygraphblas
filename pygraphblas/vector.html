<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pygraphblas.vector API documentation</title>
<meta name="description" content="GraphBLAS Sparse Vectors." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<h1>pygraphblas<h1>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygraphblas.vector</code></h1>
</header>
<section id="section-intro">
<p>GraphBLAS Sparse Vectors.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;GraphBLAS Sparse Vectors.

&#34;&#34;&#34;
import operator
import weakref
from array import array

from .base import (
    lib,
    ffi,
    NULL,
    NoValue,
    _check,
    _error_codes,
    _get_bin_op,
    _get_select_op,
    _build_range,
    GxB_INDEX_MAX,
)
from . import binaryop, unaryop, monoid, semiring as sring, types
from .scalar import Scalar
from .semiring import Semiring, current_semiring
from .binaryop import BinaryOp, current_accum, current_binop
from .unaryop import UnaryOp
from .monoid import Monoid, current_monoid
from . import descriptor
from .descriptor import Descriptor, Default, TransposeB

__all__ = [&#34;Vector&#34;]


class Vector:
    &#34;&#34;&#34;GraphBLAS Sparse Vector

    This is a high-level wrapper around the low-level GrB_Vector type.

    &#34;&#34;&#34;

    __slots__ = (&#34;vector&#34;, &#34;type&#34;, &#34;_keep_alives&#34;)

    def _check(self, res, raise_no_val=False):
        if res != lib.GrB_SUCCESS:
            if raise_no_val and res == lib.GrB_NO_VALUE:
                raise KeyError

            error_string = ffi.new(&#34;char**&#34;)
            lib.GrB_Vector_error(error_string, self.vector[0])
            raise _error_codes[res](ffi.string(error_string[0]))

    def __init__(self, vec, typ=None):
        if typ is None:
            new_type = ffi.new(&#34;GrB_Type*&#34;)
            self._check(lib.GxB_Vector_type(new_type, vec[0]))

            typ = types.gb_type_to_type(new_type[0])

        self.vector = vec
        self.type = typ
        self._keep_alives = weakref.WeakKeyDictionary()

    def __del__(self):
        self._check(lib.GrB_Vector_free(self.vector))

    def __len__(self):
        return self.nvals

    def __iter__(self):
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Vector_extractTuples(I, X, _nvals, self.vector[0]))
        return zip(I, X)

    def iseq(self, other, eq_op=None):
        &#34;&#34;&#34;Compare two vectors for equality.&#34;&#34;&#34;
        if eq_op is None:
            eq_op = self.type.EQ.get_binaryop(self.type, other.type)
        result = ffi.new(&#34;_Bool*&#34;)
        self._check(
            lib.LAGraph_Vector_isequal(result, self.vector[0], other.vector[0], eq_op)
        )
        return result[0]

    def isne(self, other):
        &#34;&#34;&#34;Compare two vectors for inequality.&#34;&#34;&#34;
        return not self.iseq(other)

    @classmethod
    def sparse(cls, typ, size=None):
        &#34;&#34;&#34;Create an empty Vector from the given type.  If `size` is not
        specified it defaults to `pygraphblas.GxB_INDEX_MAX`.

        &#34;&#34;&#34;
        if size is None:
            size = GxB_INDEX_MAX
        new_vec = ffi.new(&#34;GrB_Vector*&#34;)
        _check(lib.GrB_Vector_new(new_vec, typ.gb_type, size))
        return cls(new_vec, typ)

    @classmethod
    def from_lists(cls, I, V, size=None, typ=None):
        &#34;&#34;&#34;Create a new vector from the given lists of indices and values.  If
        size is not provided, it is computed from the max values of
        the provides size indices.

        &#34;&#34;&#34;
        assert len(I) == len(V)
        assert len(I) &gt; 0  # must be non empty
        if not size:
            size = max(I) + 1
        # TODO option to use ffi and GrB_Vector_build
        if typ is None:
            typ = types._gb_from_type(type(V[0]))
        m = cls.sparse(typ, size)
        for i, v in zip(I, V):
            m[i] = v
        return m

    @classmethod
    def from_list(cls, I):
        &#34;&#34;&#34;Create a new dense vector from the given lists of values.&#34;&#34;&#34;
        size = len(I)
        assert size &gt; 0
        # TODO use ffi and GrB_Vector_build
        m = cls.sparse(types._gb_from_type(type(I[0])), size)
        for i, v in enumerate(I):
            m[i] = v
        return m

    @classmethod
    def from_1_to_n(cls, n):
        &#34;&#34;&#34;Wrapper around LAGraph_1_to_n()&#34;&#34;&#34;
        new_vec = ffi.new(&#34;GrB_Vector*&#34;)
        _check(lib.LAGraph_1_to_n(new_vec, n))
        if n &lt; lib.INT32_MAX:
            return cls(new_vec, types.INT32)
        return cls(new_vec, types.INT64)  # pragma: no cover

    def dup(self):
        &#34;&#34;&#34;Create an duplicate Vector from the given argument.&#34;&#34;&#34;
        new_vec = ffi.new(&#34;GrB_Vector*&#34;)
        self._check(lib.GrB_Vector_dup(new_vec, self.vector[0]))
        return self.__class__(new_vec, self.type)

    @classmethod
    def dense(cls, typ, size, fill=None):
        &#34;&#34;&#34;Return a dense vector of `typ` and `size`.  If `fill` is provided,
        use that value otherwise use `type.zero`

        &#34;&#34;&#34;
        v = cls.sparse(typ, size)
        if fill is None:
            fill = v.type.zero
        v[:] = fill
        return v

    def to_lists(self):
        &#34;&#34;&#34;Extract the indices and values of the Vector as 2 lists.&#34;&#34;&#34;
        I = ffi.new(&#34;GrB_Index[]&#34;, self.nvals)
        V = self.type.ffi.new(self.type.C + &#34;[]&#34;, self.nvals)
        n = ffi.new(&#34;GrB_Index*&#34;)
        n[0] = self.nvals
        self._check(self.type.Vector_extractTuples(I, V, n, self.vector[0]))
        return [list(I), list(map(self.type.to_value, V))]

    def to_arrays(self):
        &#34;&#34;&#34;Return as python `array` objects.&#34;&#34;&#34;
        if self.type.typecode is None:
            raise TypeError(&#34;This matrix has no array typecode.&#34;)
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Vector_extractTuples(I, X, _nvals, self.vector[0]))
        return array(&#34;L&#34;, I), array(self.type.typecode, X)

    @property
    def size(self):
        &#34;&#34;&#34;Return the size of the vector.&#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Vector_size(n, self.vector[0]))
        return n[0]

    @property
    def nvals(self):
        &#34;&#34;&#34;Return the number of values in the vector.&#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Vector_nvals(n, self.vector[0]))
        return n[0]

    @property
    def gb_type(self):
        &#34;&#34;&#34;Return the GraphBLAS low-level type object of the Vector.&#34;&#34;&#34;
        typ = ffi.new(&#34;GrB_Type*&#34;)
        self._check(lib.GxB_Vector_type(typ, self.vector[0]))
        return typ[0]

    def _full(self, identity=None):
        B = self.__class__.sparse(self.type, self.size)
        if identity is None:
            identity = self.type.one

        self._check(
            self.type.Vector_assignScalar(
                B.vector[0], NULL, NULL, identity, lib.GrB_ALL, 0, NULL
            )
        )
        return self.eadd(B, binaryop.FIRST)

    def _compare(self, other, op, strop):
        C = self.__class__.sparse(types.BOOL, self.size)
        if isinstance(other, (bool, int, float, complex)):
            if op(other, 0):
                B = self.__class__.dup(self)
                B[:] = other
                self.emult(B, strop, out=C)
                return C
            else:
                self.select(strop, other).apply(lib.GxB_ONE_BOOL, out=C)
                return C
        elif isinstance(other, Vector):
            A = self._full()
            B = other._full()
            A.emult(B, strop, out=C)
            return C
        else:
            raise NotImplementedError

    def __gt__(self, other):
        return self._compare(other, operator.gt, &#34;&gt;&#34;)

    def __lt__(self, other):
        return self._compare(other, operator.lt, &#34;&lt;&#34;)

    def __ge__(self, other):
        return self._compare(other, operator.ge, &#34;&gt;=&#34;)

    def __le__(self, other):
        return self._compare(other, operator.le, &#34;&lt;=&#34;)

    def __eq__(self, other):
        return self._compare(other, operator.eq, &#34;==&#34;)

    def __ne__(self, other):
        return self._compare(other, operator.ne, &#34;!=&#34;)

    def eadd(
        self,
        other,
        add_op=None,
        cast=None,
        out=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Element-wise addition with other vector.

        Element-wise addition applies a binary operator element-wise
        on two vectors A and B, for all entries that appear in the set
        intersection of the patterns of A and B.  Other operators
        other than addition can be used.

        The pattern of the result of the element-wise addition is
        the set union of the pattern of A and B. Entries in neither in
        A nor in B do not appear in the result.

        &#34;&#34;&#34;
        if add_op is None:
            add_op = current_binop.get(binaryop.PLUS)
        if isinstance(add_op, str):
            add_op = _get_bin_op(add_op, self.type)
        if isinstance(add_op, BinaryOp):
            add_op = add_op.get_binaryop(self.type, other.type)

        mask, accum, desc = self._get_args(mask, accum, desc)

        if out is None:
            typ = cast or types.promote(self.type, other.type)
            _out = ffi.new(&#34;GrB_Vector*&#34;)
            self._check(lib.GrB_Vector_new(_out, typ.gb_type, self.size))
            out = self.__class__(_out, typ)
        self._check(
            lib.GrB_Vector_eWiseAdd_BinaryOp(
                out.vector[0],
                mask,
                accum,
                add_op,
                self.vector[0],
                other.vector[0],
                desc.desc[0],
            )
        )
        return out

    def emult(
        self,
        other,
        mult_op=None,
        cast=None,
        out=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Element-wise multiplication with other vector.

        Element-wise multiplication applies a binary operator
        element-wise on two vectors A and B, for all entries that
        appear in the set intersection of the patterns of A and B.
        Other operators other than addition can be used.

        The pattern of the result of the element-wise multiplication
        is exactly this set intersection. Entries in A but not B, or
        visa versa, do not appear in the result.

        &#34;&#34;&#34;
        if mult_op is None:
            mult_op = current_binop.get(binaryop.TIMES)
        if isinstance(mult_op, str):
            mult_op = _get_bin_op(mult_op, self.type)
        if isinstance(mult_op, BinaryOp):
            mult_op = mult_op.get_binaryop(self.type, other.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if out is None:
            typ = cast or types.promote(self.type, other.type)
            _out = ffi.new(&#34;GrB_Vector*&#34;)
            self._check(lib.GrB_Vector_new(_out, typ.gb_type, self.size))
            out = self.__class__(_out, typ)
        self._check(
            lib.GrB_Vector_eWiseMult_BinaryOp(
                out.vector[0],
                mask,
                accum,
                mult_op,
                self.vector[0],
                other.vector[0],
                desc.desc[0],
            )
        )
        return out

    def vxm(
        self,
        other,
        cast=None,
        out=None,
        semiring=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Vector-Matrix multiply.&#34;&#34;&#34;
        from .matrix import Matrix

        if semiring is None:
            semiring = current_semiring.get(None)

        mask, accum, desc = self._get_args(mask, accum, desc)
        typ = cast or types.promote(self.type, other.type, semiring)
        if out is None:
            new_dimension = other.nrows if TransposeB in desc else other.ncols
            out = Vector.sparse(typ, new_dimension)
        elif not isinstance(out, Vector):
            raise TypeError(&#34;Output argument must be Vector.&#34;)
        if semiring is None:
            semiring = typ.PLUS_TIMES
        self._check(
            lib.GrB_vxm(
                out.vector[0],
                mask,
                accum,
                semiring.get_semiring(typ),
                self.vector[0],
                other.matrix[0],
                desc.desc[0],
            )
        )
        return out

    def __matmul__(self, other):
        return self.vxm(other)

    def __imatmul__(self, other):
        return self.vxm(other, out=self)

    def __and__(self, other):
        return self.emult(other)

    def __iand__(self, other):
        return self.emult(other, out=self)

    def __or__(self, other):
        return self.eadd(other)

    def __ior__(self, other):
        return self.eadd(other, out=self)

    def __add__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.PLUS, other)
        return self.eadd(other)

    def __radd__(self, other):
        if not isinstance(other, Vector):
            return self.apply_first(other, self.type.PLUS)
        return other.eadd(self)

    def __iadd__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.PLUS, other, out=self)
        return self.eadd(other, out=self)

    def __sub__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.MINUS, other)
        return self.eadd(other, self.type.MINUS)

    def __rsub__(self, other):
        if not isinstance(other, Vector):
            return self.apply_first(other, self.type.MINUS)
        return other.eadd(self, self.type.MINUS)

    def __isub__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.MINUS, other)
        return other.eadd(self, self.type.MINUS, out=self)

    def __mul__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.TIMES, other)
        return self.eadd(other, self.type.TIMES)

    def __rmul__(self, other):
        if not isinstance(other, Vector):
            return self.apply_first(other, self.type.TIMES)
        return other.eadd(self, add_op=self.type.TIMES)

    def __imul__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.TIMES, other, out=self)
        return other.eadd(self, self.type.TIMES, out=self)

    def __truediv__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.DIV, other)
        return self.eadd(other, self.type.DIV)

    def __rtruediv__(self, other):
        if not isinstance(other, Vector):
            return self.apply_first(other, self.type.DIV)
        return other.eadd(self, self.type.DIV)

    def __itruediv__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.DIV, other, out=self)
        return other.eadd(self, self.type.DIV, out=self)

    def __invert__(self):
        return self.apply(unaryop.MINV)

    def __neg__(self):
        return self.apply(unaryop.AINV)

    def __abs__(self):
        return self.apply(unaryop.ABS)

    def clear(self):
        &#34;&#34;&#34;Clear this vector removing all entries.&#34;&#34;&#34;
        self._check(lib.GrB_Vector_clear(self.vector[0]))

    def resize(self, size):
        &#34;&#34;&#34;Resize the vector.  If the dimensions decrease, entries that fall
        outside the resized vector are deleted.

        &#34;&#34;&#34;
        self._check(lib.GrB_Vector_resize(self.vector[0], size))

    def _get_args(self, mask=None, accum=None, desc=Default):
        if accum is None or accum is NULL:
            accum = current_accum.get(NULL)
        if isinstance(accum, BinaryOp):
            accum = accum.get_binaryop(self.type)
        if mask is None:
            mask = NULL
        if isinstance(mask, Vector):
            mask = mask.vector[0]
        return mask, accum, desc

    def reduce_bool(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce vector to a boolean.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.BOOL.LOR_MONOID)
        mon = mon.get_monoid(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        result = ffi.new(&#34;_Bool*&#34;)
        self._check(
            lib.GrB_Vector_reduce_BOOL(result, accum, mon, self.vector[0], desc.desc[0])
        )
        return result[0]

    def reduce_int(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce vector to a integer.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.INT64.PLUS_MONOID)
        mon = mon.get_monoid(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        result = ffi.new(&#34;int64_t*&#34;)
        self._check(
            lib.GrB_Vector_reduce_INT64(
                result, accum, mon, self.vector[0], desc.desc[0]
            )
        )
        return result[0]

    def reduce_float(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce vector to a float.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.FP64.PLUS_MONOID)
        mon = mon.get_monoid(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        result = ffi.new(&#34;double*&#34;)
        self._check(
            lib.GrB_Vector_reduce_FP64(result, accum, mon, self.vector[0], desc.desc[0])
        )
        return result[0]

    def apply(self, op, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply Unary op to vector elements.&#34;&#34;&#34;
        if out is None:
            out = Vector.sparse(self.type, self.size)
        if isinstance(op, UnaryOp):
            op = op.get_unaryop(self)

        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Vector_apply(
                out.vector[0], mask, accum, op, self.vector[0], desc.desc[0]
            )
        )
        return out

    def apply_first(self, first, op, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply a binary operator to the entries in a vector, binding the first input
        to a scalar first.
        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.size)
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if isinstance(first, Scalar):
            f = lib.GxB_Vector_apply_BinaryOp1st
            first = first.scalar[0]
        else:
            f = self.type.Vector_apply_BinaryOp1st
        self._check(
            f(out.vector[0], mask, accum, op, first, self.vector[0], desc.desc[0])
        )
        return out

    def apply_second(self, op, second, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply a binary operator to the entries in a vector, binding the second input
        to a scalar second.

        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.size)
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if isinstance(second, Scalar):
            f = lib.GxB_Vector_apply_BinaryOp2nd
            second = second.scalar[0]
        else:
            f = self.type.Vector_apply_BinaryOp2nd
        self._check(
            f(out.vector[0], mask, accum, op, self.vector[0], second, desc.desc[0])
        )
        return out

    def select(self, op, thunk=None, out=None, mask=None, accum=None, desc=Default):
        if out is None:
            out = Vector.sparse(self.type, self.size)
        if isinstance(op, str):
            op = _get_select_op(op)

        if thunk is None:
            thunk = NULL
        if isinstance(thunk, (bool, int, float, complex)):
            thunk = Scalar.from_value(thunk)
        if isinstance(thunk, Scalar):
            self._keep_alives[self.vector] = thunk
            thunk = thunk.scalar[0]

        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GxB_Vector_select(
                out.vector[0], mask, accum, op, self.vector[0], thunk, desc.desc[0]
            )
        )
        return out

    def pattern(self, typ=types.BOOL):
        &#34;&#34;&#34;Return the pattern of the vector, this is a boolean Vector where
        every present value in this vector is set to True.

        &#34;&#34;&#34;
        result = Vector.sparse(typ, self.size)
        self.apply(types.BOOL.ONE, out=result)
        return result

    def nonzero(self):
        &#34;&#34;&#34;Select vector of nonzero entries.&#34;&#34;&#34;
        return self.select(lib.GxB_NONZERO)

    def to_dense(self, _id=None):
        &#34;&#34;&#34;Convert to dense vector.&#34;&#34;&#34;
        out = ffi.new(&#34;GrB_Vector*&#34;)
        if _id is None:
            _id = ffi.new(self.type.ptr, 0)
        self._check(lib.LAGraph_Vector_to_dense(out, self.vector[0], _id))
        return Vector(out, self.type)

    def __setitem__(self, index, value):
        if isinstance(index, int):
            val = self.type.from_value(value)
            self._check(self.type.Vector_setElement(self.vector[0], val, index))
            return

        if isinstance(index, slice):
            if isinstance(value, Vector):
                self.assign(value, index)
                return
            if isinstance(value, (bool, int, float, complex)):
                self.assign_scalar(value, index)
                return
        raise TypeError(&#34;Unknown index or value for vector assignment.&#34;)

    def assign(self, value, index=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Assign vector to vector.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        I, ni, size = _build_range(index, self.size - 1)
        self._check(
            lib.GrB_Vector_assign(
                self.vector[0], mask, accum, value.vector[0], I, ni, desc.desc[0]
            )
        )

    def assign_scalar(self, value, index=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Assign scalar to vector.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        scalar_type = types._gb_from_type(type(value))
        I, ni, size = _build_range(index, self.size - 1)
        self._check(
            scalar_type.Vector_assignScalar(
                self.vector[0], mask, accum, value, I, ni, desc.desc[0]
            )
        )

    def __getitem__(self, index):
        if isinstance(index, int):
            return self.extract_element(index)
        else:
            return self.extract(index)

    def __delitem__(self, index):
        if not isinstance(index, int):
            raise TypeError(
                &#34;__delitem__ currently only supports single element removal&#34;
            )
        self._check(lib.GrB_Vector_removeElement(self.vector[0], index))

    def extract_element(self, index):
        &#34;&#34;&#34;Extract element from vector.&#34;&#34;&#34;
        result = self.type.ffi.new(self.type.ptr)
        self._check(
            self.type.Vector_extractElement(
                result, self.vector[0], ffi.cast(&#34;GrB_Index&#34;, index)
            )
        )
        return self.type.to_value(result[0])

    def extract(self, index, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Extract subvector from vector.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        if isinstance(index, Vector):
            mask = index.vector[0]
            index = slice(None, None, None)
        I, ni, size = _build_range(index, self.size - 1)
        if size is None:
            size = self.size
        result = Vector.sparse(self.type, size)
        self._check(
            lib.GrB_Vector_extract(
                result.vector[0], mask, accum, self.vector[0], I, ni, desc.desc[0]
            )
        )
        return result

    def __contains__(self, index):
        try:
            v = self[index]
            return True
        except NoValue:
            return False

    def get(self, i, default=None):
        &#34;&#34;&#34;Get element at `i` or return `default` if not present.&#34;&#34;&#34;
        try:
            return self[i]
        except NoValue:
            return default

    def wait(self):
        &#34;&#34;&#34;Wait for vector to complete.&#34;&#34;&#34;
        self._check(lib.GrB_Vector_wait(self.vector))

    def to_string(self, format_string=&#34;{:&gt;%s}&#34;, width=2, empty_char=&#34;&#34;):
        &#34;&#34;&#34;Return string representation of vector.&#34;&#34;&#34;
        format_string = format_string % width
        result = &#34;&#34;
        for row in range(self.size):
            value = self.get(row, empty_char)
            result += str(row) + &#34;|&#34;
            result += format_string.format(self.type.format_value(value, width)) + &#34;\n&#34;
        return result

    def __str__(self):
        return self.to_string()

    def __repr__(self):
        return &#34;&lt;Vector (%s: %s:%s)&gt;&#34; % (self.size, self.nvals, self.type.__name__)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygraphblas.vector.Vector"><code class="flex name class">
<span>class <span class="ident">Vector</span></span>
<span>(</span><span>vec, typ=None)</span>
</code></dt>
<dd>
<div class="desc"><p>GraphBLAS Sparse Vector</p>
<p>This is a high-level wrapper around the low-level GrB_Vector type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vector:
    &#34;&#34;&#34;GraphBLAS Sparse Vector

    This is a high-level wrapper around the low-level GrB_Vector type.

    &#34;&#34;&#34;

    __slots__ = (&#34;vector&#34;, &#34;type&#34;, &#34;_keep_alives&#34;)

    def _check(self, res, raise_no_val=False):
        if res != lib.GrB_SUCCESS:
            if raise_no_val and res == lib.GrB_NO_VALUE:
                raise KeyError

            error_string = ffi.new(&#34;char**&#34;)
            lib.GrB_Vector_error(error_string, self.vector[0])
            raise _error_codes[res](ffi.string(error_string[0]))

    def __init__(self, vec, typ=None):
        if typ is None:
            new_type = ffi.new(&#34;GrB_Type*&#34;)
            self._check(lib.GxB_Vector_type(new_type, vec[0]))

            typ = types.gb_type_to_type(new_type[0])

        self.vector = vec
        self.type = typ
        self._keep_alives = weakref.WeakKeyDictionary()

    def __del__(self):
        self._check(lib.GrB_Vector_free(self.vector))

    def __len__(self):
        return self.nvals

    def __iter__(self):
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Vector_extractTuples(I, X, _nvals, self.vector[0]))
        return zip(I, X)

    def iseq(self, other, eq_op=None):
        &#34;&#34;&#34;Compare two vectors for equality.&#34;&#34;&#34;
        if eq_op is None:
            eq_op = self.type.EQ.get_binaryop(self.type, other.type)
        result = ffi.new(&#34;_Bool*&#34;)
        self._check(
            lib.LAGraph_Vector_isequal(result, self.vector[0], other.vector[0], eq_op)
        )
        return result[0]

    def isne(self, other):
        &#34;&#34;&#34;Compare two vectors for inequality.&#34;&#34;&#34;
        return not self.iseq(other)

    @classmethod
    def sparse(cls, typ, size=None):
        &#34;&#34;&#34;Create an empty Vector from the given type.  If `size` is not
        specified it defaults to `pygraphblas.GxB_INDEX_MAX`.

        &#34;&#34;&#34;
        if size is None:
            size = GxB_INDEX_MAX
        new_vec = ffi.new(&#34;GrB_Vector*&#34;)
        _check(lib.GrB_Vector_new(new_vec, typ.gb_type, size))
        return cls(new_vec, typ)

    @classmethod
    def from_lists(cls, I, V, size=None, typ=None):
        &#34;&#34;&#34;Create a new vector from the given lists of indices and values.  If
        size is not provided, it is computed from the max values of
        the provides size indices.

        &#34;&#34;&#34;
        assert len(I) == len(V)
        assert len(I) &gt; 0  # must be non empty
        if not size:
            size = max(I) + 1
        # TODO option to use ffi and GrB_Vector_build
        if typ is None:
            typ = types._gb_from_type(type(V[0]))
        m = cls.sparse(typ, size)
        for i, v in zip(I, V):
            m[i] = v
        return m

    @classmethod
    def from_list(cls, I):
        &#34;&#34;&#34;Create a new dense vector from the given lists of values.&#34;&#34;&#34;
        size = len(I)
        assert size &gt; 0
        # TODO use ffi and GrB_Vector_build
        m = cls.sparse(types._gb_from_type(type(I[0])), size)
        for i, v in enumerate(I):
            m[i] = v
        return m

    @classmethod
    def from_1_to_n(cls, n):
        &#34;&#34;&#34;Wrapper around LAGraph_1_to_n()&#34;&#34;&#34;
        new_vec = ffi.new(&#34;GrB_Vector*&#34;)
        _check(lib.LAGraph_1_to_n(new_vec, n))
        if n &lt; lib.INT32_MAX:
            return cls(new_vec, types.INT32)
        return cls(new_vec, types.INT64)  # pragma: no cover

    def dup(self):
        &#34;&#34;&#34;Create an duplicate Vector from the given argument.&#34;&#34;&#34;
        new_vec = ffi.new(&#34;GrB_Vector*&#34;)
        self._check(lib.GrB_Vector_dup(new_vec, self.vector[0]))
        return self.__class__(new_vec, self.type)

    @classmethod
    def dense(cls, typ, size, fill=None):
        &#34;&#34;&#34;Return a dense vector of `typ` and `size`.  If `fill` is provided,
        use that value otherwise use `type.zero`

        &#34;&#34;&#34;
        v = cls.sparse(typ, size)
        if fill is None:
            fill = v.type.zero
        v[:] = fill
        return v

    def to_lists(self):
        &#34;&#34;&#34;Extract the indices and values of the Vector as 2 lists.&#34;&#34;&#34;
        I = ffi.new(&#34;GrB_Index[]&#34;, self.nvals)
        V = self.type.ffi.new(self.type.C + &#34;[]&#34;, self.nvals)
        n = ffi.new(&#34;GrB_Index*&#34;)
        n[0] = self.nvals
        self._check(self.type.Vector_extractTuples(I, V, n, self.vector[0]))
        return [list(I), list(map(self.type.to_value, V))]

    def to_arrays(self):
        &#34;&#34;&#34;Return as python `array` objects.&#34;&#34;&#34;
        if self.type.typecode is None:
            raise TypeError(&#34;This matrix has no array typecode.&#34;)
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Vector_extractTuples(I, X, _nvals, self.vector[0]))
        return array(&#34;L&#34;, I), array(self.type.typecode, X)

    @property
    def size(self):
        &#34;&#34;&#34;Return the size of the vector.&#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Vector_size(n, self.vector[0]))
        return n[0]

    @property
    def nvals(self):
        &#34;&#34;&#34;Return the number of values in the vector.&#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Vector_nvals(n, self.vector[0]))
        return n[0]

    @property
    def gb_type(self):
        &#34;&#34;&#34;Return the GraphBLAS low-level type object of the Vector.&#34;&#34;&#34;
        typ = ffi.new(&#34;GrB_Type*&#34;)
        self._check(lib.GxB_Vector_type(typ, self.vector[0]))
        return typ[0]

    def _full(self, identity=None):
        B = self.__class__.sparse(self.type, self.size)
        if identity is None:
            identity = self.type.one

        self._check(
            self.type.Vector_assignScalar(
                B.vector[0], NULL, NULL, identity, lib.GrB_ALL, 0, NULL
            )
        )
        return self.eadd(B, binaryop.FIRST)

    def _compare(self, other, op, strop):
        C = self.__class__.sparse(types.BOOL, self.size)
        if isinstance(other, (bool, int, float, complex)):
            if op(other, 0):
                B = self.__class__.dup(self)
                B[:] = other
                self.emult(B, strop, out=C)
                return C
            else:
                self.select(strop, other).apply(lib.GxB_ONE_BOOL, out=C)
                return C
        elif isinstance(other, Vector):
            A = self._full()
            B = other._full()
            A.emult(B, strop, out=C)
            return C
        else:
            raise NotImplementedError

    def __gt__(self, other):
        return self._compare(other, operator.gt, &#34;&gt;&#34;)

    def __lt__(self, other):
        return self._compare(other, operator.lt, &#34;&lt;&#34;)

    def __ge__(self, other):
        return self._compare(other, operator.ge, &#34;&gt;=&#34;)

    def __le__(self, other):
        return self._compare(other, operator.le, &#34;&lt;=&#34;)

    def __eq__(self, other):
        return self._compare(other, operator.eq, &#34;==&#34;)

    def __ne__(self, other):
        return self._compare(other, operator.ne, &#34;!=&#34;)

    def eadd(
        self,
        other,
        add_op=None,
        cast=None,
        out=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Element-wise addition with other vector.

        Element-wise addition applies a binary operator element-wise
        on two vectors A and B, for all entries that appear in the set
        intersection of the patterns of A and B.  Other operators
        other than addition can be used.

        The pattern of the result of the element-wise addition is
        the set union of the pattern of A and B. Entries in neither in
        A nor in B do not appear in the result.

        &#34;&#34;&#34;
        if add_op is None:
            add_op = current_binop.get(binaryop.PLUS)
        if isinstance(add_op, str):
            add_op = _get_bin_op(add_op, self.type)
        if isinstance(add_op, BinaryOp):
            add_op = add_op.get_binaryop(self.type, other.type)

        mask, accum, desc = self._get_args(mask, accum, desc)

        if out is None:
            typ = cast or types.promote(self.type, other.type)
            _out = ffi.new(&#34;GrB_Vector*&#34;)
            self._check(lib.GrB_Vector_new(_out, typ.gb_type, self.size))
            out = self.__class__(_out, typ)
        self._check(
            lib.GrB_Vector_eWiseAdd_BinaryOp(
                out.vector[0],
                mask,
                accum,
                add_op,
                self.vector[0],
                other.vector[0],
                desc.desc[0],
            )
        )
        return out

    def emult(
        self,
        other,
        mult_op=None,
        cast=None,
        out=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Element-wise multiplication with other vector.

        Element-wise multiplication applies a binary operator
        element-wise on two vectors A and B, for all entries that
        appear in the set intersection of the patterns of A and B.
        Other operators other than addition can be used.

        The pattern of the result of the element-wise multiplication
        is exactly this set intersection. Entries in A but not B, or
        visa versa, do not appear in the result.

        &#34;&#34;&#34;
        if mult_op is None:
            mult_op = current_binop.get(binaryop.TIMES)
        if isinstance(mult_op, str):
            mult_op = _get_bin_op(mult_op, self.type)
        if isinstance(mult_op, BinaryOp):
            mult_op = mult_op.get_binaryop(self.type, other.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if out is None:
            typ = cast or types.promote(self.type, other.type)
            _out = ffi.new(&#34;GrB_Vector*&#34;)
            self._check(lib.GrB_Vector_new(_out, typ.gb_type, self.size))
            out = self.__class__(_out, typ)
        self._check(
            lib.GrB_Vector_eWiseMult_BinaryOp(
                out.vector[0],
                mask,
                accum,
                mult_op,
                self.vector[0],
                other.vector[0],
                desc.desc[0],
            )
        )
        return out

    def vxm(
        self,
        other,
        cast=None,
        out=None,
        semiring=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Vector-Matrix multiply.&#34;&#34;&#34;
        from .matrix import Matrix

        if semiring is None:
            semiring = current_semiring.get(None)

        mask, accum, desc = self._get_args(mask, accum, desc)
        typ = cast or types.promote(self.type, other.type, semiring)
        if out is None:
            new_dimension = other.nrows if TransposeB in desc else other.ncols
            out = Vector.sparse(typ, new_dimension)
        elif not isinstance(out, Vector):
            raise TypeError(&#34;Output argument must be Vector.&#34;)
        if semiring is None:
            semiring = typ.PLUS_TIMES
        self._check(
            lib.GrB_vxm(
                out.vector[0],
                mask,
                accum,
                semiring.get_semiring(typ),
                self.vector[0],
                other.matrix[0],
                desc.desc[0],
            )
        )
        return out

    def __matmul__(self, other):
        return self.vxm(other)

    def __imatmul__(self, other):
        return self.vxm(other, out=self)

    def __and__(self, other):
        return self.emult(other)

    def __iand__(self, other):
        return self.emult(other, out=self)

    def __or__(self, other):
        return self.eadd(other)

    def __ior__(self, other):
        return self.eadd(other, out=self)

    def __add__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.PLUS, other)
        return self.eadd(other)

    def __radd__(self, other):
        if not isinstance(other, Vector):
            return self.apply_first(other, self.type.PLUS)
        return other.eadd(self)

    def __iadd__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.PLUS, other, out=self)
        return self.eadd(other, out=self)

    def __sub__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.MINUS, other)
        return self.eadd(other, self.type.MINUS)

    def __rsub__(self, other):
        if not isinstance(other, Vector):
            return self.apply_first(other, self.type.MINUS)
        return other.eadd(self, self.type.MINUS)

    def __isub__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.MINUS, other)
        return other.eadd(self, self.type.MINUS, out=self)

    def __mul__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.TIMES, other)
        return self.eadd(other, self.type.TIMES)

    def __rmul__(self, other):
        if not isinstance(other, Vector):
            return self.apply_first(other, self.type.TIMES)
        return other.eadd(self, add_op=self.type.TIMES)

    def __imul__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.TIMES, other, out=self)
        return other.eadd(self, self.type.TIMES, out=self)

    def __truediv__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.DIV, other)
        return self.eadd(other, self.type.DIV)

    def __rtruediv__(self, other):
        if not isinstance(other, Vector):
            return self.apply_first(other, self.type.DIV)
        return other.eadd(self, self.type.DIV)

    def __itruediv__(self, other):
        if not isinstance(other, Vector):
            return self.apply_second(self.type.DIV, other, out=self)
        return other.eadd(self, self.type.DIV, out=self)

    def __invert__(self):
        return self.apply(unaryop.MINV)

    def __neg__(self):
        return self.apply(unaryop.AINV)

    def __abs__(self):
        return self.apply(unaryop.ABS)

    def clear(self):
        &#34;&#34;&#34;Clear this vector removing all entries.&#34;&#34;&#34;
        self._check(lib.GrB_Vector_clear(self.vector[0]))

    def resize(self, size):
        &#34;&#34;&#34;Resize the vector.  If the dimensions decrease, entries that fall
        outside the resized vector are deleted.

        &#34;&#34;&#34;
        self._check(lib.GrB_Vector_resize(self.vector[0], size))

    def _get_args(self, mask=None, accum=None, desc=Default):
        if accum is None or accum is NULL:
            accum = current_accum.get(NULL)
        if isinstance(accum, BinaryOp):
            accum = accum.get_binaryop(self.type)
        if mask is None:
            mask = NULL
        if isinstance(mask, Vector):
            mask = mask.vector[0]
        return mask, accum, desc

    def reduce_bool(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce vector to a boolean.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.BOOL.LOR_MONOID)
        mon = mon.get_monoid(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        result = ffi.new(&#34;_Bool*&#34;)
        self._check(
            lib.GrB_Vector_reduce_BOOL(result, accum, mon, self.vector[0], desc.desc[0])
        )
        return result[0]

    def reduce_int(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce vector to a integer.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.INT64.PLUS_MONOID)
        mon = mon.get_monoid(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        result = ffi.new(&#34;int64_t*&#34;)
        self._check(
            lib.GrB_Vector_reduce_INT64(
                result, accum, mon, self.vector[0], desc.desc[0]
            )
        )
        return result[0]

    def reduce_float(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce vector to a float.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.FP64.PLUS_MONOID)
        mon = mon.get_monoid(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        result = ffi.new(&#34;double*&#34;)
        self._check(
            lib.GrB_Vector_reduce_FP64(result, accum, mon, self.vector[0], desc.desc[0])
        )
        return result[0]

    def apply(self, op, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply Unary op to vector elements.&#34;&#34;&#34;
        if out is None:
            out = Vector.sparse(self.type, self.size)
        if isinstance(op, UnaryOp):
            op = op.get_unaryop(self)

        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Vector_apply(
                out.vector[0], mask, accum, op, self.vector[0], desc.desc[0]
            )
        )
        return out

    def apply_first(self, first, op, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply a binary operator to the entries in a vector, binding the first input
        to a scalar first.
        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.size)
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if isinstance(first, Scalar):
            f = lib.GxB_Vector_apply_BinaryOp1st
            first = first.scalar[0]
        else:
            f = self.type.Vector_apply_BinaryOp1st
        self._check(
            f(out.vector[0], mask, accum, op, first, self.vector[0], desc.desc[0])
        )
        return out

    def apply_second(self, op, second, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply a binary operator to the entries in a vector, binding the second input
        to a scalar second.

        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.size)
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if isinstance(second, Scalar):
            f = lib.GxB_Vector_apply_BinaryOp2nd
            second = second.scalar[0]
        else:
            f = self.type.Vector_apply_BinaryOp2nd
        self._check(
            f(out.vector[0], mask, accum, op, self.vector[0], second, desc.desc[0])
        )
        return out

    def select(self, op, thunk=None, out=None, mask=None, accum=None, desc=Default):
        if out is None:
            out = Vector.sparse(self.type, self.size)
        if isinstance(op, str):
            op = _get_select_op(op)

        if thunk is None:
            thunk = NULL
        if isinstance(thunk, (bool, int, float, complex)):
            thunk = Scalar.from_value(thunk)
        if isinstance(thunk, Scalar):
            self._keep_alives[self.vector] = thunk
            thunk = thunk.scalar[0]

        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GxB_Vector_select(
                out.vector[0], mask, accum, op, self.vector[0], thunk, desc.desc[0]
            )
        )
        return out

    def pattern(self, typ=types.BOOL):
        &#34;&#34;&#34;Return the pattern of the vector, this is a boolean Vector where
        every present value in this vector is set to True.

        &#34;&#34;&#34;
        result = Vector.sparse(typ, self.size)
        self.apply(types.BOOL.ONE, out=result)
        return result

    def nonzero(self):
        &#34;&#34;&#34;Select vector of nonzero entries.&#34;&#34;&#34;
        return self.select(lib.GxB_NONZERO)

    def to_dense(self, _id=None):
        &#34;&#34;&#34;Convert to dense vector.&#34;&#34;&#34;
        out = ffi.new(&#34;GrB_Vector*&#34;)
        if _id is None:
            _id = ffi.new(self.type.ptr, 0)
        self._check(lib.LAGraph_Vector_to_dense(out, self.vector[0], _id))
        return Vector(out, self.type)

    def __setitem__(self, index, value):
        if isinstance(index, int):
            val = self.type.from_value(value)
            self._check(self.type.Vector_setElement(self.vector[0], val, index))
            return

        if isinstance(index, slice):
            if isinstance(value, Vector):
                self.assign(value, index)
                return
            if isinstance(value, (bool, int, float, complex)):
                self.assign_scalar(value, index)
                return
        raise TypeError(&#34;Unknown index or value for vector assignment.&#34;)

    def assign(self, value, index=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Assign vector to vector.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        I, ni, size = _build_range(index, self.size - 1)
        self._check(
            lib.GrB_Vector_assign(
                self.vector[0], mask, accum, value.vector[0], I, ni, desc.desc[0]
            )
        )

    def assign_scalar(self, value, index=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Assign scalar to vector.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        scalar_type = types._gb_from_type(type(value))
        I, ni, size = _build_range(index, self.size - 1)
        self._check(
            scalar_type.Vector_assignScalar(
                self.vector[0], mask, accum, value, I, ni, desc.desc[0]
            )
        )

    def __getitem__(self, index):
        if isinstance(index, int):
            return self.extract_element(index)
        else:
            return self.extract(index)

    def __delitem__(self, index):
        if not isinstance(index, int):
            raise TypeError(
                &#34;__delitem__ currently only supports single element removal&#34;
            )
        self._check(lib.GrB_Vector_removeElement(self.vector[0], index))

    def extract_element(self, index):
        &#34;&#34;&#34;Extract element from vector.&#34;&#34;&#34;
        result = self.type.ffi.new(self.type.ptr)
        self._check(
            self.type.Vector_extractElement(
                result, self.vector[0], ffi.cast(&#34;GrB_Index&#34;, index)
            )
        )
        return self.type.to_value(result[0])

    def extract(self, index, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Extract subvector from vector.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        if isinstance(index, Vector):
            mask = index.vector[0]
            index = slice(None, None, None)
        I, ni, size = _build_range(index, self.size - 1)
        if size is None:
            size = self.size
        result = Vector.sparse(self.type, size)
        self._check(
            lib.GrB_Vector_extract(
                result.vector[0], mask, accum, self.vector[0], I, ni, desc.desc[0]
            )
        )
        return result

    def __contains__(self, index):
        try:
            v = self[index]
            return True
        except NoValue:
            return False

    def get(self, i, default=None):
        &#34;&#34;&#34;Get element at `i` or return `default` if not present.&#34;&#34;&#34;
        try:
            return self[i]
        except NoValue:
            return default

    def wait(self):
        &#34;&#34;&#34;Wait for vector to complete.&#34;&#34;&#34;
        self._check(lib.GrB_Vector_wait(self.vector))

    def to_string(self, format_string=&#34;{:&gt;%s}&#34;, width=2, empty_char=&#34;&#34;):
        &#34;&#34;&#34;Return string representation of vector.&#34;&#34;&#34;
        format_string = format_string % width
        result = &#34;&#34;
        for row in range(self.size):
            value = self.get(row, empty_char)
            result += str(row) + &#34;|&#34;
            result += format_string.format(self.type.format_value(value, width)) + &#34;\n&#34;
        return result

    def __str__(self):
        return self.to_string()

    def __repr__(self):
        return &#34;&lt;Vector (%s: %s:%s)&gt;&#34; % (self.size, self.nvals, self.type.__name__)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pygraphblas.vector.Vector.dense"><code class="name flex">
<span>def <span class="ident">dense</span></span>(<span>typ, size, fill=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dense vector of <code>typ</code> and <code>size</code>.
If <code>fill</code> is provided,
use that value otherwise use <code>type.zero</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def dense(cls, typ, size, fill=None):
    &#34;&#34;&#34;Return a dense vector of `typ` and `size`.  If `fill` is provided,
    use that value otherwise use `type.zero`

    &#34;&#34;&#34;
    v = cls.sparse(typ, size)
    if fill is None:
        fill = v.type.zero
    v[:] = fill
    return v</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.from_1_to_n"><code class="name flex">
<span>def <span class="ident">from_1_to_n</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper around LAGraph_1_to_n()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_1_to_n(cls, n):
    &#34;&#34;&#34;Wrapper around LAGraph_1_to_n()&#34;&#34;&#34;
    new_vec = ffi.new(&#34;GrB_Vector*&#34;)
    _check(lib.LAGraph_1_to_n(new_vec, n))
    if n &lt; lib.INT32_MAX:
        return cls(new_vec, types.INT32)
    return cls(new_vec, types.INT64)  # pragma: no cover</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.from_list"><code class="name flex">
<span>def <span class="ident">from_list</span></span>(<span>I)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new dense vector from the given lists of values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_list(cls, I):
    &#34;&#34;&#34;Create a new dense vector from the given lists of values.&#34;&#34;&#34;
    size = len(I)
    assert size &gt; 0
    # TODO use ffi and GrB_Vector_build
    m = cls.sparse(types._gb_from_type(type(I[0])), size)
    for i, v in enumerate(I):
        m[i] = v
    return m</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.from_lists"><code class="name flex">
<span>def <span class="ident">from_lists</span></span>(<span>I, V, size=None, typ=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new vector from the given lists of indices and values.
If
size is not provided, it is computed from the max values of
the provides size indices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_lists(cls, I, V, size=None, typ=None):
    &#34;&#34;&#34;Create a new vector from the given lists of indices and values.  If
    size is not provided, it is computed from the max values of
    the provides size indices.

    &#34;&#34;&#34;
    assert len(I) == len(V)
    assert len(I) &gt; 0  # must be non empty
    if not size:
        size = max(I) + 1
    # TODO option to use ffi and GrB_Vector_build
    if typ is None:
        typ = types._gb_from_type(type(V[0]))
    m = cls.sparse(typ, size)
    for i, v in zip(I, V):
        m[i] = v
    return m</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.sparse"><code class="name flex">
<span>def <span class="ident">sparse</span></span>(<span>typ, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an empty Vector from the given type.
If <code>size</code> is not
specified it defaults to <code>pygraphblas.GxB_INDEX_MAX</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def sparse(cls, typ, size=None):
    &#34;&#34;&#34;Create an empty Vector from the given type.  If `size` is not
    specified it defaults to `pygraphblas.GxB_INDEX_MAX`.

    &#34;&#34;&#34;
    if size is None:
        size = GxB_INDEX_MAX
    new_vec = ffi.new(&#34;GrB_Vector*&#34;)
    _check(lib.GrB_Vector_new(new_vec, typ.gb_type, size))
    return cls(new_vec, typ)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pygraphblas.vector.Vector.gb_type"><code class="name">var <span class="ident">gb_type</span></code></dt>
<dd>
<div class="desc"><p>Return the GraphBLAS low-level type object of the Vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gb_type(self):
    &#34;&#34;&#34;Return the GraphBLAS low-level type object of the Vector.&#34;&#34;&#34;
    typ = ffi.new(&#34;GrB_Type*&#34;)
    self._check(lib.GxB_Vector_type(typ, self.vector[0]))
    return typ[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.nvals"><code class="name">var <span class="ident">nvals</span></code></dt>
<dd>
<div class="desc"><p>Return the number of values in the vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nvals(self):
    &#34;&#34;&#34;Return the number of values in the vector.&#34;&#34;&#34;
    n = ffi.new(&#34;GrB_Index*&#34;)
    self._check(lib.GrB_Vector_nvals(n, self.vector[0]))
    return n[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Return the size of the vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    &#34;&#34;&#34;Return the size of the vector.&#34;&#34;&#34;
    n = ffi.new(&#34;GrB_Index*&#34;)
    self._check(lib.GrB_Vector_size(n, self.vector[0]))
    return n[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pygraphblas.vector.Vector.vector"><code class="name">var <span class="ident">vector</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygraphblas.vector.Vector.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, op, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply Unary op to vector elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, op, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Apply Unary op to vector elements.&#34;&#34;&#34;
    if out is None:
        out = Vector.sparse(self.type, self.size)
    if isinstance(op, UnaryOp):
        op = op.get_unaryop(self)

    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        lib.GrB_Vector_apply(
            out.vector[0], mask, accum, op, self.vector[0], desc.desc[0]
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.apply_first"><code class="name flex">
<span>def <span class="ident">apply_first</span></span>(<span>self, first, op, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a binary operator to the entries in a vector, binding the first input
to a scalar first.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_first(self, first, op, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Apply a binary operator to the entries in a vector, binding the first input
    to a scalar first.
    &#34;&#34;&#34;
    if out is None:
        out = self.__class__.sparse(self.type, self.size)
    if isinstance(op, BinaryOp):
        op = op.get_binaryop(self)
    mask, accum, desc = self._get_args(mask, accum, desc)
    if isinstance(first, Scalar):
        f = lib.GxB_Vector_apply_BinaryOp1st
        first = first.scalar[0]
    else:
        f = self.type.Vector_apply_BinaryOp1st
    self._check(
        f(out.vector[0], mask, accum, op, first, self.vector[0], desc.desc[0])
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.apply_second"><code class="name flex">
<span>def <span class="ident">apply_second</span></span>(<span>self, op, second, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a binary operator to the entries in a vector, binding the second input
to a scalar second.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_second(self, op, second, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Apply a binary operator to the entries in a vector, binding the second input
    to a scalar second.

    &#34;&#34;&#34;
    if out is None:
        out = self.__class__.sparse(self.type, self.size)
    if isinstance(op, BinaryOp):
        op = op.get_binaryop(self)
    mask, accum, desc = self._get_args(mask, accum, desc)
    if isinstance(second, Scalar):
        f = lib.GxB_Vector_apply_BinaryOp2nd
        second = second.scalar[0]
    else:
        f = self.type.Vector_apply_BinaryOp2nd
    self._check(
        f(out.vector[0], mask, accum, op, self.vector[0], second, desc.desc[0])
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.assign"><code class="name flex">
<span>def <span class="ident">assign</span></span>(<span>self, value, index=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign vector to vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign(self, value, index=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Assign vector to vector.&#34;&#34;&#34;
    mask, accum, desc = self._get_args(mask, accum, desc)
    I, ni, size = _build_range(index, self.size - 1)
    self._check(
        lib.GrB_Vector_assign(
            self.vector[0], mask, accum, value.vector[0], I, ni, desc.desc[0]
        )
    )</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.assign_scalar"><code class="name flex">
<span>def <span class="ident">assign_scalar</span></span>(<span>self, value, index=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign scalar to vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_scalar(self, value, index=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Assign scalar to vector.&#34;&#34;&#34;
    mask, accum, desc = self._get_args(mask, accum, desc)
    scalar_type = types._gb_from_type(type(value))
    I, ni, size = _build_range(index, self.size - 1)
    self._check(
        scalar_type.Vector_assignScalar(
            self.vector[0], mask, accum, value, I, ni, desc.desc[0]
        )
    )</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear this vector removing all entries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Clear this vector removing all entries.&#34;&#34;&#34;
    self._check(lib.GrB_Vector_clear(self.vector[0]))</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.dup"><code class="name flex">
<span>def <span class="ident">dup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an duplicate Vector from the given argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dup(self):
    &#34;&#34;&#34;Create an duplicate Vector from the given argument.&#34;&#34;&#34;
    new_vec = ffi.new(&#34;GrB_Vector*&#34;)
    self._check(lib.GrB_Vector_dup(new_vec, self.vector[0]))
    return self.__class__(new_vec, self.type)</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.eadd"><code class="name flex">
<span>def <span class="ident">eadd</span></span>(<span>self, other, add_op=None, cast=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Element-wise addition with other vector.</p>
<p>Element-wise addition applies a binary operator element-wise
on two vectors A and B, for all entries that appear in the set
intersection of the patterns of A and B.
Other operators
other than addition can be used.</p>
<p>The pattern of the result of the element-wise addition is
the set union of the pattern of A and B. Entries in neither in
A nor in B do not appear in the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eadd(
    self,
    other,
    add_op=None,
    cast=None,
    out=None,
    mask=None,
    accum=None,
    desc=Default,
):
    &#34;&#34;&#34;Element-wise addition with other vector.

    Element-wise addition applies a binary operator element-wise
    on two vectors A and B, for all entries that appear in the set
    intersection of the patterns of A and B.  Other operators
    other than addition can be used.

    The pattern of the result of the element-wise addition is
    the set union of the pattern of A and B. Entries in neither in
    A nor in B do not appear in the result.

    &#34;&#34;&#34;
    if add_op is None:
        add_op = current_binop.get(binaryop.PLUS)
    if isinstance(add_op, str):
        add_op = _get_bin_op(add_op, self.type)
    if isinstance(add_op, BinaryOp):
        add_op = add_op.get_binaryop(self.type, other.type)

    mask, accum, desc = self._get_args(mask, accum, desc)

    if out is None:
        typ = cast or types.promote(self.type, other.type)
        _out = ffi.new(&#34;GrB_Vector*&#34;)
        self._check(lib.GrB_Vector_new(_out, typ.gb_type, self.size))
        out = self.__class__(_out, typ)
    self._check(
        lib.GrB_Vector_eWiseAdd_BinaryOp(
            out.vector[0],
            mask,
            accum,
            add_op,
            self.vector[0],
            other.vector[0],
            desc.desc[0],
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.emult"><code class="name flex">
<span>def <span class="ident">emult</span></span>(<span>self, other, mult_op=None, cast=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Element-wise multiplication with other vector.</p>
<p>Element-wise multiplication applies a binary operator
element-wise on two vectors A and B, for all entries that
appear in the set intersection of the patterns of A and B.
Other operators other than addition can be used.</p>
<p>The pattern of the result of the element-wise multiplication
is exactly this set intersection. Entries in A but not B, or
visa versa, do not appear in the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emult(
    self,
    other,
    mult_op=None,
    cast=None,
    out=None,
    mask=None,
    accum=None,
    desc=Default,
):
    &#34;&#34;&#34;Element-wise multiplication with other vector.

    Element-wise multiplication applies a binary operator
    element-wise on two vectors A and B, for all entries that
    appear in the set intersection of the patterns of A and B.
    Other operators other than addition can be used.

    The pattern of the result of the element-wise multiplication
    is exactly this set intersection. Entries in A but not B, or
    visa versa, do not appear in the result.

    &#34;&#34;&#34;
    if mult_op is None:
        mult_op = current_binop.get(binaryop.TIMES)
    if isinstance(mult_op, str):
        mult_op = _get_bin_op(mult_op, self.type)
    if isinstance(mult_op, BinaryOp):
        mult_op = mult_op.get_binaryop(self.type, other.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    if out is None:
        typ = cast or types.promote(self.type, other.type)
        _out = ffi.new(&#34;GrB_Vector*&#34;)
        self._check(lib.GrB_Vector_new(_out, typ.gb_type, self.size))
        out = self.__class__(_out, typ)
    self._check(
        lib.GrB_Vector_eWiseMult_BinaryOp(
            out.vector[0],
            mask,
            accum,
            mult_op,
            self.vector[0],
            other.vector[0],
            desc.desc[0],
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, index, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract subvector from vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(self, index, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Extract subvector from vector.&#34;&#34;&#34;
    mask, accum, desc = self._get_args(mask, accum, desc)
    if isinstance(index, Vector):
        mask = index.vector[0]
        index = slice(None, None, None)
    I, ni, size = _build_range(index, self.size - 1)
    if size is None:
        size = self.size
    result = Vector.sparse(self.type, size)
    self._check(
        lib.GrB_Vector_extract(
            result.vector[0], mask, accum, self.vector[0], I, ni, desc.desc[0]
        )
    )
    return result</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.extract_element"><code class="name flex">
<span>def <span class="ident">extract_element</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract element from vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_element(self, index):
    &#34;&#34;&#34;Extract element from vector.&#34;&#34;&#34;
    result = self.type.ffi.new(self.type.ptr)
    self._check(
        self.type.Vector_extractElement(
            result, self.vector[0], ffi.cast(&#34;GrB_Index&#34;, index)
        )
    )
    return self.type.to_value(result[0])</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, i, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get element at <code>i</code> or return <code>default</code> if not present.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, i, default=None):
    &#34;&#34;&#34;Get element at `i` or return `default` if not present.&#34;&#34;&#34;
    try:
        return self[i]
    except NoValue:
        return default</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.iseq"><code class="name flex">
<span>def <span class="ident">iseq</span></span>(<span>self, other, eq_op=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare two vectors for equality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iseq(self, other, eq_op=None):
    &#34;&#34;&#34;Compare two vectors for equality.&#34;&#34;&#34;
    if eq_op is None:
        eq_op = self.type.EQ.get_binaryop(self.type, other.type)
    result = ffi.new(&#34;_Bool*&#34;)
    self._check(
        lib.LAGraph_Vector_isequal(result, self.vector[0], other.vector[0], eq_op)
    )
    return result[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.isne"><code class="name flex">
<span>def <span class="ident">isne</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare two vectors for inequality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isne(self, other):
    &#34;&#34;&#34;Compare two vectors for inequality.&#34;&#34;&#34;
    return not self.iseq(other)</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.nonzero"><code class="name flex">
<span>def <span class="ident">nonzero</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Select vector of nonzero entries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nonzero(self):
    &#34;&#34;&#34;Select vector of nonzero entries.&#34;&#34;&#34;
    return self.select(lib.GxB_NONZERO)</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.pattern"><code class="name flex">
<span>def <span class="ident">pattern</span></span>(<span>self, typ=pygraphblas.types.BOOL)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the pattern of the vector, this is a boolean Vector where
every present value in this vector is set to True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pattern(self, typ=types.BOOL):
    &#34;&#34;&#34;Return the pattern of the vector, this is a boolean Vector where
    every present value in this vector is set to True.

    &#34;&#34;&#34;
    result = Vector.sparse(typ, self.size)
    self.apply(types.BOOL.ONE, out=result)
    return result</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.reduce_bool"><code class="name flex">
<span>def <span class="ident">reduce_bool</span></span>(<span>self, mon=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce vector to a boolean.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_bool(self, mon=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Reduce vector to a boolean.&#34;&#34;&#34;
    if mon is None:
        mon = current_monoid.get(types.BOOL.LOR_MONOID)
    mon = mon.get_monoid(self.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    result = ffi.new(&#34;_Bool*&#34;)
    self._check(
        lib.GrB_Vector_reduce_BOOL(result, accum, mon, self.vector[0], desc.desc[0])
    )
    return result[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.reduce_float"><code class="name flex">
<span>def <span class="ident">reduce_float</span></span>(<span>self, mon=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce vector to a float.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_float(self, mon=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Reduce vector to a float.&#34;&#34;&#34;
    if mon is None:
        mon = current_monoid.get(types.FP64.PLUS_MONOID)
    mon = mon.get_monoid(self.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    result = ffi.new(&#34;double*&#34;)
    self._check(
        lib.GrB_Vector_reduce_FP64(result, accum, mon, self.vector[0], desc.desc[0])
    )
    return result[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.reduce_int"><code class="name flex">
<span>def <span class="ident">reduce_int</span></span>(<span>self, mon=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce vector to a integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_int(self, mon=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Reduce vector to a integer.&#34;&#34;&#34;
    if mon is None:
        mon = current_monoid.get(types.INT64.PLUS_MONOID)
    mon = mon.get_monoid(self.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    result = ffi.new(&#34;int64_t*&#34;)
    self._check(
        lib.GrB_Vector_reduce_INT64(
            result, accum, mon, self.vector[0], desc.desc[0]
        )
    )
    return result[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Resize the vector.
If the dimensions decrease, entries that fall
outside the resized vector are deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize(self, size):
    &#34;&#34;&#34;Resize the vector.  If the dimensions decrease, entries that fall
    outside the resized vector are deleted.

    &#34;&#34;&#34;
    self._check(lib.GrB_Vector_resize(self.vector[0], size))</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, op, thunk=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, op, thunk=None, out=None, mask=None, accum=None, desc=Default):
    if out is None:
        out = Vector.sparse(self.type, self.size)
    if isinstance(op, str):
        op = _get_select_op(op)

    if thunk is None:
        thunk = NULL
    if isinstance(thunk, (bool, int, float, complex)):
        thunk = Scalar.from_value(thunk)
    if isinstance(thunk, Scalar):
        self._keep_alives[self.vector] = thunk
        thunk = thunk.scalar[0]

    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        lib.GxB_Vector_select(
            out.vector[0], mask, accum, op, self.vector[0], thunk, desc.desc[0]
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.to_arrays"><code class="name flex">
<span>def <span class="ident">to_arrays</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return as python <code>array</code> objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_arrays(self):
    &#34;&#34;&#34;Return as python `array` objects.&#34;&#34;&#34;
    if self.type.typecode is None:
        raise TypeError(&#34;This matrix has no array typecode.&#34;)
    nvals = self.nvals
    _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
    I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
    X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
    self._check(self.type.Vector_extractTuples(I, X, _nvals, self.vector[0]))
    return array(&#34;L&#34;, I), array(self.type.typecode, X)</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.to_dense"><code class="name flex">
<span>def <span class="ident">to_dense</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to dense vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dense(self, _id=None):
    &#34;&#34;&#34;Convert to dense vector.&#34;&#34;&#34;
    out = ffi.new(&#34;GrB_Vector*&#34;)
    if _id is None:
        _id = ffi.new(self.type.ptr, 0)
    self._check(lib.LAGraph_Vector_to_dense(out, self.vector[0], _id))
    return Vector(out, self.type)</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.to_lists"><code class="name flex">
<span>def <span class="ident">to_lists</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the indices and values of the Vector as 2 lists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_lists(self):
    &#34;&#34;&#34;Extract the indices and values of the Vector as 2 lists.&#34;&#34;&#34;
    I = ffi.new(&#34;GrB_Index[]&#34;, self.nvals)
    V = self.type.ffi.new(self.type.C + &#34;[]&#34;, self.nvals)
    n = ffi.new(&#34;GrB_Index*&#34;)
    n[0] = self.nvals
    self._check(self.type.Vector_extractTuples(I, V, n, self.vector[0]))
    return [list(I), list(map(self.type.to_value, V))]</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self, format_string=&#x27;{:&gt;%s}&#x27;, width=2, empty_char='')</span>
</code></dt>
<dd>
<div class="desc"><p>Return string representation of vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(self, format_string=&#34;{:&gt;%s}&#34;, width=2, empty_char=&#34;&#34;):
    &#34;&#34;&#34;Return string representation of vector.&#34;&#34;&#34;
    format_string = format_string % width
    result = &#34;&#34;
    for row in range(self.size):
        value = self.get(row, empty_char)
        result += str(row) + &#34;|&#34;
        result += format_string.format(self.type.format_value(value, width)) + &#34;\n&#34;
    return result</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.vxm"><code class="name flex">
<span>def <span class="ident">vxm</span></span>(<span>self, other, cast=None, out=None, semiring=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Vector-Matrix multiply.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vxm(
    self,
    other,
    cast=None,
    out=None,
    semiring=None,
    mask=None,
    accum=None,
    desc=Default,
):
    &#34;&#34;&#34;Vector-Matrix multiply.&#34;&#34;&#34;
    from .matrix import Matrix

    if semiring is None:
        semiring = current_semiring.get(None)

    mask, accum, desc = self._get_args(mask, accum, desc)
    typ = cast or types.promote(self.type, other.type, semiring)
    if out is None:
        new_dimension = other.nrows if TransposeB in desc else other.ncols
        out = Vector.sparse(typ, new_dimension)
    elif not isinstance(out, Vector):
        raise TypeError(&#34;Output argument must be Vector.&#34;)
    if semiring is None:
        semiring = typ.PLUS_TIMES
    self._check(
        lib.GrB_vxm(
            out.vector[0],
            mask,
            accum,
            semiring.get_semiring(typ),
            self.vector[0],
            other.matrix[0],
            desc.desc[0],
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.vector.Vector.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for vector to complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self):
    &#34;&#34;&#34;Wait for vector to complete.&#34;&#34;&#34;
    self._check(lib.GrB_Vector_wait(self.vector))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<img src="../Logo.png"/ style="width:50%;">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygraphblas" href="index.html">pygraphblas</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygraphblas.vector.Vector" href="#pygraphblas.vector.Vector">Vector</a></code></h4>
<ul class="two-column">
<li><code><a title="pygraphblas.vector.Vector.apply" href="#pygraphblas.vector.Vector.apply">apply</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.apply_first" href="#pygraphblas.vector.Vector.apply_first">apply_first</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.apply_second" href="#pygraphblas.vector.Vector.apply_second">apply_second</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.assign" href="#pygraphblas.vector.Vector.assign">assign</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.assign_scalar" href="#pygraphblas.vector.Vector.assign_scalar">assign_scalar</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.clear" href="#pygraphblas.vector.Vector.clear">clear</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.dense" href="#pygraphblas.vector.Vector.dense">dense</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.dup" href="#pygraphblas.vector.Vector.dup">dup</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.eadd" href="#pygraphblas.vector.Vector.eadd">eadd</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.emult" href="#pygraphblas.vector.Vector.emult">emult</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.extract" href="#pygraphblas.vector.Vector.extract">extract</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.extract_element" href="#pygraphblas.vector.Vector.extract_element">extract_element</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.from_1_to_n" href="#pygraphblas.vector.Vector.from_1_to_n">from_1_to_n</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.from_list" href="#pygraphblas.vector.Vector.from_list">from_list</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.from_lists" href="#pygraphblas.vector.Vector.from_lists">from_lists</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.gb_type" href="#pygraphblas.vector.Vector.gb_type">gb_type</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.get" href="#pygraphblas.vector.Vector.get">get</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.iseq" href="#pygraphblas.vector.Vector.iseq">iseq</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.isne" href="#pygraphblas.vector.Vector.isne">isne</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.nonzero" href="#pygraphblas.vector.Vector.nonzero">nonzero</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.nvals" href="#pygraphblas.vector.Vector.nvals">nvals</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.pattern" href="#pygraphblas.vector.Vector.pattern">pattern</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.reduce_bool" href="#pygraphblas.vector.Vector.reduce_bool">reduce_bool</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.reduce_float" href="#pygraphblas.vector.Vector.reduce_float">reduce_float</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.reduce_int" href="#pygraphblas.vector.Vector.reduce_int">reduce_int</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.resize" href="#pygraphblas.vector.Vector.resize">resize</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.select" href="#pygraphblas.vector.Vector.select">select</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.size" href="#pygraphblas.vector.Vector.size">size</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.sparse" href="#pygraphblas.vector.Vector.sparse">sparse</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.to_arrays" href="#pygraphblas.vector.Vector.to_arrays">to_arrays</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.to_dense" href="#pygraphblas.vector.Vector.to_dense">to_dense</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.to_lists" href="#pygraphblas.vector.Vector.to_lists">to_lists</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.to_string" href="#pygraphblas.vector.Vector.to_string">to_string</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.type" href="#pygraphblas.vector.Vector.type">type</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.vector" href="#pygraphblas.vector.Vector.vector">vector</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.vxm" href="#pygraphblas.vector.Vector.vxm">vxm</a></code></li>
<li><code><a title="pygraphblas.vector.Vector.wait" href="#pygraphblas.vector.Vector.wait">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<h4>Copyright &copy; 2021 Graphegon, Inc. Author: Michel Pelletier with
some content from Tim Davis's GraphBLAS User Guide.</h4>
<h4>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</h4>
</footer>
</body>
</html>