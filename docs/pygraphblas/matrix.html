<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pygraphblas.matrix API documentation</title>
<meta name="description" content="High level wrapper around GraphBLAS Matrices." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300;text-align:center}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<h1>pygraphblas API Reference</h1>
<h2> ~| <a href="http://graphblas.org">graphblas.org</a> | <a href="https://github.com/Graphegon/pygraphblas">Github</a> | <a href="https://raw.githubusercontent.com/DrTimothyAldenDavis/GraphBLAS/stable/Doc/GraphBLAS_UserGuide.pdf">SuiteSparse::GraphBLAS User Guide</a> |~</h2>
<h2> -| <img src="https://github.com/Graphegon/pygraphblas/workflows/Tests/badge.svg"/> | <a href="https://mybinder.org/v2/gh/Graphegon/pygraphblas/v4.0.3?filepath=pygraphblas%2Fdemo%2FIntroduction-to-GraphBLAS-with-Python.ipynb"><img src="https://mybinder.org/badge_logo.svg"/></a> |-</h2>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygraphblas.matrix</code></h1>
</header>
<section id="section-intro">
<p>High level wrapper around GraphBLAS Matrices.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;High level wrapper around GraphBLAS Matrices.

&#34;&#34;&#34;
import sys
import weakref
import operator
from random import randint
from array import array

from .base import (
    lib,
    ffi,
    NULL,
    NoValue,
    _check,
    _error_codes,
    _build_range,
    _get_select_op,
    _get_bin_op,
    GxB_INDEX_MAX,
)

from . import types, binaryop, monoid, unaryop, semiring as _semiring
from .vector import Vector
from .scalar import Scalar
from .semiring import Semiring, current_semiring
from .binaryop import BinaryOp, current_accum, current_binop
from .unaryop import UnaryOp
from .monoid import Monoid, current_monoid
from . import descriptor
from .descriptor import Descriptor, Default, TransposeA, current_desc
from .gviz import draw_graph as draw

__all__ = [&#34;Matrix&#34;]
__pdoc__ = {&#34;Matrix.__init__&#34;: False}


class Matrix:
    &#34;&#34;&#34;GraphBLAS Sparse Matrix

    This is a high-level wrapper around the GrB_Matrix C type using
    the [cffi](https://cffi.readthedocs.io/en/latest/) library.

    A Matrix supports many possible operations according to the
    GraphBLAS API.  Many of those operations have overloaded
    operators.

    Operator | Description | Default
    --- | --- | ---
    A @    B | Matrix Matrix Multiplication | type default PLUS_TIMES semiring
    v @    A | Vector Matrix Multiplication | type default PLUS_TIMES semiring
    A @    v | Matrix Vector Multiplication | type default PLUS_TIMES semiring
    A @=   B | In-place Matrix Matrix Multiplication | type default PLUS_TIMES semiring
    v @=   A | In-place Vector Matrix Multiplication | type default PLUS_TIMES semiring
    A @=   v | In-place Matrix Vector Multiplication | type default PLUS_TIMES semiring
    A \\|  B | Matrix Union | type default SECOND combiner
    A \\|= B | In-place Matrix Union | type default SECOND combiner
    A &amp;    B | Matrix Intersection | type default SECOND combiner
    A &amp;=   B | In-place Matrix Intersection | type default SECOND combiner
    A +    B | Matrix Element-Wise Union | type default PLUS combiner
    A +=   B | In-place Matrix Element-Wise Union | type default PLUS combiner
    A -    B | Matrix Element-Wise Union | type default MINUS combiner
    A -=   B | In-place Matrix Element-Wise Union | type default MINUS combiner
    A *    B | Matrix Element-Wise Intersection | type default TIMES combiner
    A *=   B | In-place Matrix Element-Wise Intersection | type default TIMES combiner
    A /    B | Matrix Element-Wise Intersection | type default DIV combiner
    A /=   B | In-place Matrix Element-Wise Intersection | type default DIV combiner

    Note that all the above operator syntax is mearly sugar over
    various combinations of calling `Matrix.mxm`, `Matrix.mxv`,
    `pygraphblas.vector.Vector.vxm`, `Matrix.eadd`, and `Matrix.emult`.

    &#34;&#34;&#34;

    __slots__ = (&#34;_matrix&#34;, &#34;type&#34;, &#34;_funcs&#34;, &#34;_keep_alives&#34;)

    def _check(self, res, raise_no_val=False):
        if res != lib.GrB_SUCCESS:
            if raise_no_val and res == lib.GrB_NO_VALUE:
                raise KeyError

            error_string = ffi.new(&#34;char**&#34;)
            lib.GrB_Matrix_error(error_string, self._matrix[0])
            raise _error_codes[res](ffi.string(error_string[0]))

    def __init__(self, matrix, typ=None):
        if typ is None:
            new_type = ffi.new(&#34;GrB_Type*&#34;)
            self._check(lib.GxB_Matrix_type(new_type, matrix[0]))

            typ = types.gb_type_to_type(new_type[0])

        self._matrix = matrix
        self.type = typ
        self._keep_alives = weakref.WeakKeyDictionary()

    def __del__(self):
        self._check(lib.GrB_Matrix_free(self._matrix))

    @classmethod
    def sparse(cls, typ, nrows=None, ncols=None):
        &#34;&#34;&#34;Create an empty sparse Matrix from the given type.  The dimensions
        can be specified with `nrows` and `ncols`.  If no dimensions
        are specified, they default to `pygraphblas.GxB_INDEX_MAX`.

        &gt;&gt;&gt; m = Matrix.sparse(types.UINT8)
        &gt;&gt;&gt; m.nrows == lib.GxB_INDEX_MAX
        True
        &gt;&gt;&gt; m.ncols == lib.GxB_INDEX_MAX
        True
        &gt;&gt;&gt; m.nvals == 0
        True

        Optional row and column dimension bounds can be provided to
        the method:

        &gt;&gt;&gt; m = Matrix.sparse(types.UINT8, 10, 10)
        &gt;&gt;&gt; m.nrows == 10
        True
        &gt;&gt;&gt; m.ncols == 10
        True
        &gt;&gt;&gt; m.nvals == 0
        True

        &#34;&#34;&#34;
        if nrows is None:
            nrows = GxB_INDEX_MAX
        if ncols is None:
            ncols = GxB_INDEX_MAX
        new_mat = ffi.new(&#34;GrB_Matrix*&#34;)
        _check(lib.GrB_Matrix_new(new_mat, typ.gb_type, nrows, ncols))
        m = cls(new_mat, typ)
        return m

    @classmethod
    def dense(cls, typ, nrows, ncols, fill=None, sparsity_control=None):
        &#34;&#34;&#34;Return a dense Matrix nrows by ncols.

        If `sparsity_control` is provided it is used for the new
        matrix (See SuiteSparse User Guide)

        &gt;&gt;&gt; m = Matrix.dense(types.UINT8, 3, 3)
        &gt;&gt;&gt; m.nrows == 3
        True
        &gt;&gt;&gt; m.ncols == 3
        True
        &gt;&gt;&gt; m.nvals == 9
        True
        &gt;&gt;&gt; for i, j, v in m:
        ...     assert v == 0

        If a `fill` value is present, use that, otherwise use the
        `zero` attribte of the given type.

        &gt;&gt;&gt; m = Matrix.dense(types.UINT8, 3, 3, fill=1)
        &gt;&gt;&gt; m.nrows == 3
        True
        &gt;&gt;&gt; m.ncols == 3
        True
        &gt;&gt;&gt; m.nvals == 9
        True
        &gt;&gt;&gt; for i, j, v in m:
        ...     assert v == 1

        &#34;&#34;&#34;
        assert nrows &gt; 0 and ncols &gt; 0, &#34;dense matrix must be at least 1x1&#34;
        m = cls.sparse(typ, nrows, ncols)
        if sparsity_control is not None:
            v.sparsity_control = sparsity_control
        if fill is None:
            fill = m.type.zero
        m[:, :] = fill
        return m

    @classmethod
    def from_lists(cls, I, J, V, nrows=None, ncols=None, typ=None):
        &#34;&#34;&#34;Create a new matrix from the given lists of row indices, column
        indices, and values.  If nrows or ncols are not provided, they
        are computed from the max values of the provides row and
        column indices lists.

        &gt;&gt;&gt; M = Matrix.from_lists([1, 2, 3], [2, 3, 1], [42, 314, 1492])
        &gt;&gt;&gt; g = draw(M, filename=&#39;/docs/imgs/Matrix_from_lists&#39;)

        ![Matrix_from_lists.png](../imgs/Matrix_from_lists.png)

        &#34;&#34;&#34;
        assert len(I) == len(J) == len(V)
        if not nrows:
            nrows = max(I) + 1
        if not ncols:
            ncols = max(J) + 1
        # TODO use ffi and GrB_Matrix_build
        if typ is None:
            typ = types._gb_from_type(type(V[0]))
        m = cls.sparse(typ, nrows, ncols)
        for i, j, v in zip(I, J, V):
            m[i, j] = v
        return m

    @classmethod
    def from_mm(cls, mm_file, typ):
        &#34;&#34;&#34;Create a new matrix by reading a Matrix Market file.&#34;&#34;&#34;
        m = ffi.new(&#34;GrB_Matrix*&#34;)
        i = cls(m, typ)
        _check(lib.LAGraph_mmread(m, mm_file))
        return i

    @classmethod
    def from_tsv(cls, tsv_file, typ, nrows, ncols):
        &#34;&#34;&#34;Create a new matrix by reading a tab separated value file.&#34;&#34;&#34;
        m = ffi.new(&#34;GrB_Matrix*&#34;)
        i = cls(m, typ)
        _check(lib.LAGraph_tsvread(m, tsv_file, typ.gb_type, nrows, ncols))
        return i

    @classmethod
    def from_binfile(cls, bin_file):
        &#34;&#34;&#34;Create a new matrix by reading a SuiteSparse specific binary file.&#34;&#34;&#34;
        m = ffi.new(&#34;GrB_Matrix*&#34;)
        _check(lib.LAGraph_binread(m, bin_file))
        return cls(m)

    @classmethod
    def random(
        cls,
        typ,
        nrows,
        ncols,
        nvals,
        make_pattern=False,
        make_symmetric=False,
        make_skew_symmetric=False,
        make_hermitian=True,
        no_diagonal=False,
        seed=None,
    ):
        &#34;&#34;&#34;Create a new random Matrix of the given type, number of rows,
        columns and values.  Other flags set additional properties the
        matrix will hold.

        &gt;&gt;&gt; M = Matrix.random(types.UINT8, 5, 5, 20, 
        ...                   make_symmetric=True, no_diagonal=True, seed=42)
        &gt;&gt;&gt; g = draw(M, filename=&#39;/docs/imgs/Matrix_random&#39;)

        ![Matrix_random.png](../imgs/Matrix_random.png)

        &#34;&#34;&#34;
        result = ffi.new(&#34;GrB_Matrix*&#34;)
        i = cls(result, typ)
        fseed = ffi.new(&#34;uint64_t*&#34;)
        if seed is None:
            seed = randint(0, sys.maxsize)
        fseed[0] = seed
        _check(
            lib.LAGraph_random(
                result,
                typ.gb_type,
                nrows,
                ncols,
                nvals,
                make_pattern,
                make_symmetric,
                make_skew_symmetric,
                make_hermitian,
                no_diagonal,
                fseed,
            )
        )
        return i

    @classmethod
    def identity(cls, typ, nrows, one=None):
        &#34;&#34;&#34;Return a new square identity Matrix of nrows with diagonal set to
        one.

        If one is None, use the default typ one value.
        &#34;&#34;&#34;
        result = cls.sparse(typ, nrows, nrows)
        if one is None:
            one = result.type.one
        for i in range(nrows):
            result[i, i] = one
        return result

    @property
    def gb_type(self):
        &#34;&#34;&#34;Return the GraphBLAS low-level type object of the Matrix.  This is
        only used if interacting with the low level API.

        &#34;&#34;&#34;
        new_type = ffi.new(&#34;GrB_Type*&#34;)
        self._check(lib.GxB_Matrix_type(new_type, self._matrix[0]))
        return new_type[0]

    @property
    def nrows(self):
        &#34;&#34;&#34;Return the number of Matrix rows.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.nrows
        3

        &#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Matrix_nrows(n, self._matrix[0]))
        return n[0]

    @property
    def ncols(self):
        &#34;&#34;&#34;Return the number of Matrix columns.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.ncols
        3

        &#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Matrix_ncols(n, self._matrix[0]))
        return n[0]

    @property
    def shape(self):
        &#34;&#34;&#34;Numpy-like description of matrix shape as 2-tuple (nrows, ncols).

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.shape
        (3, 3)

        &#34;&#34;&#34;
        return (self.nrows, self.ncols)

    @property
    def square(self):
        &#34;&#34;&#34;True if Matrix is square, else False.&#34;&#34;&#34;
        return self.nrows == self.ncols

    @property
    def nvals(self):
        &#34;&#34;&#34;Return the number of values stored in the Matrix.&#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Matrix_nvals(n, self._matrix[0]))
        return n[0]

    @property
    def T(self):
        &#34;&#34;&#34;Compute transpose of the Matrix.  See `Matrix.transpose`.

        Note: This property can be expensive, if you need the
        transpose more than once, consider storing this in a local
        variable.

        &#34;&#34;&#34;
        return self.transpose()

    def dup(self):
        &#34;&#34;&#34;Create an duplicate Matrix.

        &gt;&gt;&gt; A = Matrix.sparse(types.UINT8)
        &gt;&gt;&gt; A[1,1] = 42
        &gt;&gt;&gt; B = A.dup()
        &gt;&gt;&gt; B[1,1]
        42
        &gt;&gt;&gt; B is not A
        True

        &#34;&#34;&#34;
        new_mat = ffi.new(&#34;GrB_Matrix*&#34;)
        self._check(lib.GrB_Matrix_dup(new_mat, self._matrix[0]))
        return self.__class__(new_mat, self.type)

    @property
    def hyper_switch(self):
        &#34;&#34;&#34;Get the hyper_switch threshold. (See SuiteSparse User Guide)&#34;&#34;&#34;
        switch = ffi.new(&#34;double*&#34;)
        self._check(
            lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_HYPER_SWITCH, switch)
        )
        return switch[0]

    @hyper_switch.setter
    def hyper_switch(self, switch):
        &#34;&#34;&#34;Set the hyper_switch threshold. (See SuiteSparse User Guide)&#34;&#34;&#34;
        switch = ffi.cast(&#34;double&#34;, switch)
        self._check(
            lib.GxB_Matrix_Option_set(self._matrix[0], lib.GxB_HYPER_SWITCH, switch)
        )

    @property
    def format(self):
        &#34;&#34;&#34;Get Matrix format. (See SuiteSparse User Guide)&#34;&#34;&#34;
        format = ffi.new(&#34;GxB_Format_Value*&#34;)
        self._check(lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_FORMAT, format))
        return format[0]

    @format.setter
    def format(self, format):
        &#34;&#34;&#34;Set Matrix format. (See SuiteSparse User Guide)&#34;&#34;&#34;
        format = ffi.cast(&#34;GxB_Format_Value&#34;, format)
        self._check(lib.GxB_Matrix_Option_set(self._matrix[0], lib.GxB_FORMAT, format))

    @property
    def sparsity_control(self):
        &#34;&#34;&#34;Get Matrix sparsity control. (See SuiteSparse User Guide)&#34;&#34;&#34;
        sparsity = ffi.new(&#34;int*&#34;)
        self._check(
            lib.GxB_Matrix_Option_get(
                self._matrix[0], lib.GxB_SPARSITY_CONTROL, sparsity
            )
        )
        return sparsity[0]

    @sparsity_control.setter
    def sparsity_control(self, sparsity):
        &#34;&#34;&#34;Set Matrix sparsity control. (See SuiteSparse User Guide)&#34;&#34;&#34;
        sparsity = ffi.cast(&#34;int&#34;, sparsity)
        self._check(
            lib.GxB_Matrix_Option_set(
                self._matrix[0], lib.GxB_SPARSITY_CONTROL, sparsity
            )
        )

    @property
    def sparsity_status(self):
        &#34;&#34;&#34;Set Matrix sparsity status. (See SuiteSparse User Guide)&#34;&#34;&#34;
        status = ffi.new(&#34;int*&#34;)
        self._check(
            lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_SPARSITY_STATUS, status)
        )
        return status[0]

    def pattern(self, typ=types.BOOL):
        &#34;&#34;&#34;Return the pattern of the matrix where every present value in this
        matrix is set to identity value for the provided type which
        defaults to BOOL.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; P = M.pattern()
        &gt;&gt;&gt; P.type == types.BOOL
        True
        &gt;&gt;&gt; P[0,1]
        True

        &#34;&#34;&#34;

        r = ffi.new(&#34;GrB_Matrix*&#34;)
        self._check(lib.LAGraph_pattern(r, self._matrix[0], typ.gb_type))
        return Matrix(r, typ)

    def to_mm(self, fileobj):
        &#34;&#34;&#34;Write this matrix to a file using the Matrix Market format.&#34;&#34;&#34;
        self._check(lib.LAGraph_mmwrite(self._matrix[0], fileobj))

    def to_binfile(self, filename, comments=&#34;&#34;):
        &#34;&#34;&#34;Write this matrix using custom SuiteSparse binary format.&#34;&#34;&#34;
        self._check(
            lib.LAGraph_binwrite(self._matrix, filename, bytes(comments, &#34;utf8&#34;))
        )

    def to_lists(self):
        &#34;&#34;&#34;Extract the rows, columns and values of the Matrix as 3 lists.&#34;&#34;&#34;
        I = ffi.new(&#34;GrB_Index[%s]&#34; % self.nvals)
        J = ffi.new(&#34;GrB_Index[%s]&#34; % self.nvals)
        V = self.type.ffi.new(self.type.C + &#34;[%s]&#34; % self.nvals)
        n = ffi.new(&#34;GrB_Index*&#34;)
        n[0] = self.nvals
        self._check(self.type.Matrix_extractTuples(I, J, V, n, self._matrix[0]))
        return [list(I), list(J), list(map(self.type.to_value, V))]

    def clear(self):
        &#34;&#34;&#34;Clear the matrix.  This does not change the size but removes all
        values.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.nvals == 3
        True
        &gt;&gt;&gt; M.clear()
        &gt;&gt;&gt; M.nvals == 0
        True

        &#34;&#34;&#34;
        self._check(lib.GrB_Matrix_clear(self._matrix[0]))

    def resize(self, nrows, ncols):
        &#34;&#34;&#34;Resize the matrix.  If the dimensions decrease, entries that fall
        outside the resized matrix are deleted.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.shape
        (3, 3)
        &gt;&gt;&gt; M.resize(10, 10)
        &gt;&gt;&gt; M.shape
        (10, 10)

        &#34;&#34;&#34;
        self._check(lib.GrB_Matrix_resize(self._matrix[0], nrows, ncols))

    def transpose(self, cast=None, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Return Transpose of this matrix.

        This function can serve multiple interesting purposes
        including typecasting.  See the [SuiteSparse User
        Guide](https://raw.githubusercontent.com/DrTimothyAldenDavis/GraphBLAS/stable/Doc/GraphBLAS_UserGuide.pdf)

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; MT = M.transpose()
        &gt;&gt;&gt; MT.to_lists()
        [[0, 1, 2], [2, 0, 1], [1492, 42, 314]]

        &gt;&gt;&gt; MT = M.transpose(cast=types.BOOL, desc=descriptor.T0)
        &gt;&gt;&gt; MT.to_lists()
        [[0, 1, 2], [1, 2, 0], [True, True, True]]

        &#34;&#34;&#34;
        if out is None:
            new_dimensions = (
                (self.nrows, self.ncols)
                if TransposeA in desc
                else (self.ncols, self.nrows)
            )
            _out = ffi.new(&#34;GrB_Matrix*&#34;)
            if cast is not None:
                typ = cast
            else:
                typ = self.type
            self._check(lib.GrB_Matrix_new(_out, typ.gb_type, *new_dimensions))
            out = self.__class__(_out, typ)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(lib.GrB_transpose(out._matrix[0], mask, accum, self._matrix[0], desc))
        return out

    def cast(self, cast, out=None):
        &#34;&#34;&#34;Cast this matrix to the provided type.  If out is not provided, a
        new matrix is of the cast type is created.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; N = M.cast(types.BOOL)
        &gt;&gt;&gt; N.to_lists()
        [[0, 1, 2], [1, 2, 0], [True, True, True]]

        &#34;&#34;&#34;
        return self.transpose(cast, out, desc=TransposeA)

    def eadd(
        self,
        other,
        add_op=None,
        cast=None,
        out=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Element-wise addition with other matrix.

        Element-wise addition applies a binary operator element-wise
        on two matrices A and B, for all entries that appear in the
        set intersection of the patterns of A and B.  Other operators
        other than addition can be used.

        The pattern of the result of the element-wise addition is
        the set union of the pattern of A and B. Entries in neither in
        A nor in B do not appear in the result.

        The only difference between element-wise multiplication and
        addition is the pattern of the result, and what happens to
        entries outside the intersection. With multiplication the
        pattern of T is the intersection; with addition it is the set
        union. Entries outside the set intersection are dropped for
        multiplication, and kept for addition; in both cases the
        operator is only applied to those (and only those) entries in
        the intersection. Any binary operator can be used
        interchangeably for either operation.

        &#34;&#34;&#34;
        if add_op is None:
            add_op = current_binop.get(binaryop.PLUS)
        elif isinstance(add_op, str):
            add_op = _get_bin_op(add_op, self.type)

        add_op = add_op.get_binaryop(self.type, other.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if out is None:
            typ = cast or types.promote(self.type, other.type)
            _out = ffi.new(&#34;GrB_Matrix*&#34;)
            self._check(lib.GrB_Matrix_new(_out, typ.gb_type, self.nrows, self.ncols))
            out = Matrix(_out, typ)

        self._check(
            lib.GrB_Matrix_eWiseAdd_BinaryOp(
                out._matrix[0],
                mask,
                accum,
                add_op,
                self._matrix[0],
                other._matrix[0],
                desc,
            )
        )
        return out

    def emult(
        self,
        other,
        mult_op=None,
        cast=None,
        out=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Element-wise multiplication with other matrix.

        Element-wise multiplication applies a binary operator
        element-wise on two matrices A and B, for all entries that
        appear in the set intersection of the patterns of A and B.
        Other operators other than addition can be used.

        The pattern of the result of the element-wise multiplication
        is exactly this set intersection. Entries in A but not B, or
        visa versa, do not appear in the result.

        The only difference between element-wise multiplication and
        addition is the pattern of the result, and what happens to
        entries outside the intersection. With multiplication the
        pattern of T is the intersection; with addition it is the set
        union. Entries outside the set intersection are dropped for
        multiplication, and kept for addition; in both cases the
        operator is only applied to those (and only those) entries in
        the intersection. Any binary operator can be used
        interchangeably for either operation.

        &#34;&#34;&#34;
        if mult_op is None:
            mult_op = current_binop.get(binaryop.TIMES)
        elif isinstance(mult_op, str):
            mult_op = _get_bin_op(mult_op, self.type)

        mult_op = mult_op.get_binaryop(self.type, other.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if out is None:
            typ = cast or types.promote(self.type, other.type)
            _out = ffi.new(&#34;GrB_Matrix*&#34;)
            self._check(lib.GrB_Matrix_new(_out, typ.gb_type, self.nrows, self.ncols))
            out = Matrix(_out, typ)

        self._check(
            lib.GrB_Matrix_eWiseMult_BinaryOp(
                out._matrix[0],
                mask,
                accum,
                mult_op,
                self._matrix[0],
                other._matrix[0],
                desc,
            )
        )
        return out

    def iseq(self, other):
        &#34;&#34;&#34;Compare two matrices for equality returning True or False.  

        Not to be confused with `==` which will return a matrix of
        BOOL values comparing *elements* for equality.

        Uses code from LAGraph_isequal.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; N = M.dup()
        &gt;&gt;&gt; M.iseq(N)
        True
        &gt;&gt;&gt; del N[0, 1]
        &gt;&gt;&gt; M.iseq(N)
        False

        &#34;&#34;&#34;
        result = ffi.new(&#34;_Bool*&#34;)
        eq_op = self.type.EQ.get_binaryop(self.type, other.type)
        self._check(lib.LAGraph_isequal(result, self._matrix[0], other._matrix[0], eq_op))
        return result[0]

    def isne(self, other):
        &#34;&#34;&#34;Compare two matrices for inequality.  See `Matrix.iseq`.

        &#34;&#34;&#34;
        return not self.iseq(other)

    def __iter__(self):
        &#34;&#34;&#34;Iterate over the (row, col, value) triples of the Matrix.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; sorted(list(iter(M)))
        [(0, 1, 42), (1, 2, 314), (2, 0, 1492)]

        &#34;&#34;&#34;
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        J = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return zip(I, J, map(self.type.to_value, X))

    def to_arrays(self):
        &#34;&#34;&#34;Convert Matrix to tuple of three dense array objects.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.to_arrays()
        (array(&#39;L&#39;, [0, 1, 2]), array(&#39;L&#39;, [1, 2, 0]), array(&#39;q&#39;, [42, 314, 1492]))

        &#34;&#34;&#34;
        if self.type.typecode is None:
            raise TypeError(&#34;This matrix has no array typecode.&#34;)
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        J = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return array(&#34;L&#34;, I), array(&#34;L&#34;, J), array(self.type.typecode, X)

    @property
    def rows(self):
        &#34;&#34;&#34;An iterator of row indexes present in the matrix.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; list(M.rows)
        [0, 1, 2]

        &#34;&#34;&#34;
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        J = NULL
        X = NULL
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return iter(I)

    @property
    def cols(self):
        &#34;&#34;&#34;An iterator of column indexes present in the matrix.


        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; list(M.cols)
        [1, 2, 0]

        &#34;&#34;&#34;
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = NULL
        J = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = NULL
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return iter(J)

    @property
    def vals(self):
        &#34;&#34;&#34;An iterator of values present in the matrix.


        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; list(M.vals)
        [42, 314, 1492]

        &#34;&#34;&#34;
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = NULL
        J = NULL
        X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return iter(X)

    def __len__(self):
        &#34;&#34;&#34;Return the number of elements in the Matrix.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; len(M)
        3

        &#34;&#34;&#34;
        return self.nvals

    def __and__(self, other):
        return self.emult(other, self.type.SECOND)

    def __iand__(self, other):
        return self.emult(other, self.type.SECOND, out=self)

    def __or__(self, other):
        return self.eadd(other, self.type.SECOND)

    def __ior__(self, other):
        return self.eadd(other, self.type.SECOND, out=self)

    def __add__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.PLUS, other)
        return self.eadd(other)

    def __radd__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_first(other, self.type.PLUS)
        return other.eadd(self)

    def __iadd__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.PLUS, other, out=self)
        return self.eadd(other, out=self)

    def __sub__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.MINUS, other)
        return self.eadd(other, add_op=self.type.MINUS)

    def __rsub__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_first(other, self.type.MINUS)
        return other.eadd(self, add_op=self.type.MINUS)

    def __isub__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.MINUS, other, out=self)
        return other.eadd(self, out=self, add_op=self.type.MINUS)

    def __mul__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.TIMES, other)
        return self.eadd(other, add_op=self.type.TIMES)

    def __rmul__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_first(other, self.type.TIMES)
        return other.eadd(self, add_op=self.type.TIMES)

    def __imul__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.TIMES, other)
        return other.eadd(self, out=self, add_op=self.type.TIMES)

    def __truediv__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.DIV, other)
        return self.eadd(other, add_op=self.type.DIV)

    def __rtruediv__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_first(other, self.type.DIV)
        return other.eadd(self, add_op=self.type.DIV)

    def __itruediv__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.DIV, other)
        return other.eadd(self, out=self, add_op=self.type.DIV)

    def __invert__(self):
        return self.apply(unaryop.MINV)

    def __neg__(self):
        return self.apply(unaryop.AINV)

    def __abs__(self):
        return self.apply(unaryop.ABS)

    def __pow__(self, exponent):
        if exponent == 0:
            return self.__class__.identity(self.type, self.nrows)
        if exponent == 1:
            return self
        result = self.dup()
        for i in range(1, exponent):
            result.mxm(self, out=result)
        return result

    def reduce_bool(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce matrix to a boolean.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.BOOL.LOR_MONOID)
        mon = mon.get_monoid(self.type)
        result = ffi.new(&#34;_Bool*&#34;)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Matrix_reduce_BOOL(result, accum, mon, self._matrix[0], desc)
        )
        return result[0]

    def reduce_int(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce matrix to an integer.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.INT64.PLUS_MONOID)
        mon = mon.get_monoid(self.type)
        result = ffi.new(&#34;int64_t*&#34;)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Matrix_reduce_INT64(result, accum, mon, self._matrix[0], desc)
        )
        return result[0]

    def reduce_float(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce matrix to an float.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(self.type.PLUS_MONOID)
        mon = mon.get_monoid(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        result = ffi.new(&#34;double*&#34;)
        self._check(
            lib.GrB_Matrix_reduce_FP64(result, accum, mon, self._matrix[0], desc)
        )
        return result[0]

    def reduce_vector(self, mon=None, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce matrix to a vector.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(getattr(self.type, &#34;PLUS_MONOID&#34;, NULL))
        mon = mon.get_monoid(self.type)
        if out is None:
            out = Vector.sparse(self.type, self.nrows)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Matrix_reduce_Monoid(
                out._vector[0], mask, accum, mon, self._matrix[0], desc
            )
        )
        return out

    def apply(self, op, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply Unary op to matrix elements.&#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if isinstance(op, UnaryOp):
            op = op.get_unaryop(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Matrix_apply(out._matrix[0], mask, accum, op, self._matrix[0], desc)
        )
        return out

    def apply_first(self, first, op, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply a binary operator to the entries in a matrix, binding the
        first input to a scalar first.

        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if isinstance(first, Scalar):
            f = lib.GxB_Matrix_apply_BinaryOp1st
        else:
            f = self.type.Matrix_apply_BinaryOp1st
        self._check(f(out._matrix[0], mask, accum, op, first, self._matrix[0], desc))
        return out

    def apply_second(self, op, second, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply a binary operator to the entries in a matrix, binding the
        second input to a scalar second.

        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            self.type.Matrix_apply_BinaryOp2nd(
                out._matrix[0], mask, accum, op, self._matrix[0], second, desc
            )
        )
        return out

    def select(self, op, thunk=None, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Select elements that match the given select operation condition.
        Can be a string mapping to following operators:

            &#34;&gt;&#34;: lib.GxB_GT_THUNK
            &#34;&lt;&#34;: lib.GxB_LT_THUNK
            &#34;&gt;=&#34;: lib.GxB_GE_THUNK
            &#34;&lt;=&#34;: lib.GxB_LE_THUNK
            &#34;!=&#34;: lib.GxB_NE_THUNK
            &#34;==&#34;: lib.GxB_EQ_THUNK
            &#34;&gt;0&#34;: lib.GxB_GT_ZERO
            &#34;&lt;0&#34;: lib.GxB_LT_ZERO
            &#34;&gt;=0&#34;: lib.GxB_GE_ZERO
            &#34;&lt;=0&#34;: lib.GxB_LE_ZERO
            &#34;!=0&#34;: lib.GxB_NONZERO
            &#34;==0&#34;: lib.GxB_EQ_ZERO

        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if isinstance(op, str):
            op = _get_select_op(op)

        if thunk is None:
            thunk = NULL
        if isinstance(thunk, (bool, int, float, complex)):
            thunk = Scalar.from_value(thunk)
        if isinstance(thunk, Scalar):
            self._keep_alives[self._matrix] = thunk
            thunk = thunk.scalar[0]

        mask, accum, desc = self._get_args(mask, accum, desc)

        self._check(
            lib.GxB_Matrix_select(
                out._matrix[0], mask, accum, op, self._matrix[0], thunk, desc
            )
        )
        return out

    def tril(self, thunk=None):
        &#34;&#34;&#34;Select the lower triangular Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_TRIL, thunk=thunk)

    def triu(self, thunk=None):
        &#34;&#34;&#34;Select the upper triangular Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_TRIU, thunk=thunk)

    def diag(self, thunk=None):
        &#34;&#34;&#34;Select the diagonal Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_DIAG, thunk=thunk)

    def offdiag(self, thunk=None):
        &#34;&#34;&#34;Select the off-diagonal Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_OFFDIAG, thunk=thunk)

    def nonzero(self):
        &#34;&#34;&#34;Select the non-zero Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_NONZERO)

    def _full(self, identity=None):
        &#34;&#34;&#34;&#34;&#34;&#34;
        B = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if identity is None:
            identity = self.type.one

        self._check(
            self.type.Matrix_assignScalar(
                B._matrix[0], NULL, NULL, identity, lib.GrB_ALL, 0, lib.GrB_ALL, 0, NULL
            )
        )
        return self.eadd(B, self.type.FIRST)

    def _compare(self, other, op, strop):
        C = self.__class__.sparse(types.BOOL, self.nrows, self.ncols)
        if isinstance(other, (bool, int, float, complex)):
            if op(other, 0):
                B = self.__class__.dup(self)
                B[:, :] = other
                self.emult(B, strop, out=C)
                return C
            else:
                self.select(strop, other).apply(types.BOOL.ONE, out=C)
                return C
        elif isinstance(other, Matrix):
            A = self._full()
            B = other._full()
            A.emult(B, strop, out=C)
            return C
        else:
            raise TypeError(&#34;Unknown matrix comparison type.&#34;)

    def __gt__(self, other):
        return self._compare(other, operator.gt, &#34;&gt;&#34;)

    def __lt__(self, other):
        return self._compare(other, operator.lt, &#34;&lt;&#34;)

    def __ge__(self, other):
        return self._compare(other, operator.ge, &#34;&gt;=&#34;)

    def __le__(self, other):
        return self._compare(other, operator.le, &#34;&lt;=&#34;)

    def __eq__(self, other):
        return self._compare(other, operator.eq, &#34;==&#34;)

    def __ne__(self, other):
        return self._compare(other, operator.ne, &#34;!=&#34;)

    def _get_args(self, mask=None, accum=None, desc=Default):
        if isinstance(mask, Matrix):
            mask = mask._matrix[0]
        elif isinstance(mask, Vector):
            mask = mask._vector[0]
        else:
            mask = NULL
        if accum is None:
            accum = current_accum.get(NULL)
        if isinstance(accum, BinaryOp):
            accum = accum.get_binaryop(self.type)
        if desc is None or desc == Default:
            desc = current_desc.get(Default)
        if isinstance(desc, Descriptor):
            desc = desc.desc[0]
        return mask, accum, desc

    def mxm(
        self,
        other,
        cast=None,
        out=None,
        semiring=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Matrix-matrix multiply.&#34;&#34;&#34;
        if semiring is None:
            semiring = current_semiring.get(None)

        typ = cast or types.promote(self.type, other.type, semiring)
        if out is None:
            out = self.__class__.sparse(typ, self.nrows, other.ncols)

        if semiring is None:
            semiring = typ.PLUS_TIMES

        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_mxm(
                out._matrix[0],
                mask,
                accum,
                semiring.get_semiring(typ),
                self._matrix[0],
                other._matrix[0],
                desc,
            )
        )
        return out

    def mxv(
        self,
        other,
        cast=None,
        out=None,
        semiring=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Matrix-vector multiply.&#34;&#34;&#34;
        if semiring is None:
            semiring = current_semiring.get(None)

        typ = cast or types.promote(self.type, other.type, semiring)
        if out is None:
            new_dimension = self.ncols if TransposeA in desc else self.nrows
            out = Vector.sparse(typ, new_dimension)

        mask, accum, desc = self._get_args(mask, accum, desc)
        if semiring is None:
            semiring = typ.PLUS_TIMES

        self._check(
            lib.GrB_mxv(
                out._vector[0],
                mask,
                accum,
                semiring.get_semiring(typ),
                self._matrix[0],
                other._vector[0],
                desc,
            )
        )
        return out

    def __matmul__(self, other):
        if isinstance(other, Matrix):
            return self.mxm(other)
        elif isinstance(other, Vector):
            return self.mxv(other)
        else:
            raise TypeError(&#34;Right argument to @ must be Matrix or Vector.&#34;)

    def __imatmul__(self, other):
        return self.mxm(other, out=self)

    def kronecker(self, other, op=None, cast=None, out=None,
                  mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Kronecker product.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        typ = cast or types.promote(self.type, other.type)
        if out is None:
            out = self.__class__.sparse(
                typ, self.nrows * other.nrows, self.ncols * other.ncols
            )
        if op is None:
            op = typ.TIMES
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self.type, other.type)

        self._check(
            lib.GrB_Matrix_kronecker_BinaryOp(
                out._matrix[0], mask, accum, op, self._matrix[0], other._matrix[0], desc
            )
        )
        return out

    def extract_matrix(self, rindex=None, cindex=None, out=None,
                       mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Extract a submatrix.&#34;&#34;&#34;
        ta = TransposeA in desc
        mask, accum, desc = self._get_args(mask, accum, desc)
        result_nrows = self.ncols if ta else self.nrows
        result_ncols = self.nrows if ta else self.ncols
        I, ni, isize = _build_range(rindex, result_nrows - 1)
        J, nj, jsize = _build_range(cindex, result_ncols - 1)
        if isize is None:
            isize = result_nrows
        if jsize is None:
            jsize = result_ncols

        if out is None:
            out = self.__class__.sparse(self.type, isize, jsize)

        self._check(
            lib.GrB_Matrix_extract(
                out._matrix[0], mask, accum, self._matrix[0], I, ni, J, nj, desc
            )
        )
        return out

    def extract_col(self, col_index, row_slice=None, out=None,
                    mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Extract a column Vector.&#34;&#34;&#34;
        stop_val = self.ncols if TransposeA in desc else self.nrows
        if out is None:
            out = Vector.sparse(self.type, stop_val)

        mask, accum, desc = self._get_args(mask, accum, desc)
        I, ni, size = _build_range(row_slice, stop_val)

        self._check(
            lib.GrB_Col_extract(
                out._vector[0], mask, accum, self._matrix[0], I, ni, col_index, desc
            )
        )
        return out

    def extract_row(self, row_index, col_slice=None, out=None,
                    mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Extract a row Vector.&#34;&#34;&#34;
        desc = desc | TransposeA
        return self.extract_col(
            row_index, col_slice, out, desc=desc, mask=None, accum=None
        )

    def __getitem__(self, index):
        if isinstance(index, int):
            # a[3] extract single row
            return self.extract_row(index, None)
        if isinstance(index, slice):
            # a[3:] extract submatrix of rows
            return self.extract_matrix(index, None)

        if isinstance(index, Matrix):
            return self.extract_matrix(mask=index)

        if not isinstance(index, (tuple, list)):
            raise TypeError

        i0 = index[0]
        i1 = index[1]
        if isinstance(i0, int) and isinstance(i1, int):
            # a[3,3] extract single element
            result = self.type.ffi.new(self.type.ptr)
            self._check(
                self.type.Matrix_extractElement(
                    result, self._matrix[0], index[0], index[1]
                )
            )
            return self.type.to_value(result[0])

        if isinstance(i0, int) and isinstance(i1, slice):
            # a[3,:] extract slice of row vector
            return self.extract_row(i0, i1)

        if isinstance(i0, slice) and isinstance(i1, int):
            # a[:,3] extract slice of col vector
            return self.extract_col(i1, i0)

        # a[:,:] or a[[0,1,2], [3,4,5]] extract submatrix with slice or row/col indices
        return self.extract_matrix(i0, i1)

    def assign_col(self, col_index, value, row_slice=None, mask=None,
                   accum=None, desc=Default):
        &#34;&#34;&#34;Assign a vector to a column.&#34;&#34;&#34;
        stop_val = self.ncols if TransposeA in desc else self.nrows
        I, ni, size = _build_range(row_slice, stop_val)
        mask, accum, desc = self._get_args(mask, accum, desc)

        self._check(
            lib.GrB_Col_assign(
                self._matrix[0], mask, accum, value._vector[0], I, ni, col_index, desc
            )
        )

    def assign_row(self, row_index, value, col_slice=None, mask=None,
                   accum=None, desc=Default):
        &#34;&#34;&#34;Assign a vector to a row.&#34;&#34;&#34;
        stop_val = self.nrows if TransposeA in desc else self.ncols
        I, ni, size = _build_range(col_slice, stop_val)

        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Row_assign(
                self._matrix[0], mask, accum, value._vector[0], row_index, I, ni, desc
            )
        )

    def assign_matrix(self, value, rindex=None, cindex=None,
                      mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Assign a submatrix.&#34;&#34;&#34;
        I, ni, isize = _build_range(rindex, self.nrows - 1)
        J, nj, jsize = _build_range(cindex, self.ncols - 1)
        if isize is None:
            isize = self.nrows
        if jsize is None:
            jsize = self.ncols

        mask, accum, desc = self._get_args(mask, accum, desc)

        self._check(
            lib.GrB_Matrix_assign(
                self._matrix[0], mask, accum, value._matrix[0], I, ni, J, nj, desc
            )
        )

    def assign_scalar(self, value, row_slice=None, col_slice=None,
                      mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Assign a scalar to the Matrix.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        if row_slice:
            I, ni, isize = _build_range(row_slice, self.nrows - 1)
        else:
            I = lib.GrB_ALL
            ni = 0
        if col_slice:
            J, nj, jsize = _build_range(col_slice, self.ncols - 1)
        else:
            J = lib.GrB_ALL
            nj = 0
        scalar_type = types._gb_from_type(type(value))
        self._check(
            scalar_type.Matrix_assignScalar(
                self._matrix[0], mask, accum, value, I, ni, J, nj, desc
            )
        )

    def __setitem__(self, index, value):
        if isinstance(index, int):
            # A[3] = assign single row  vector
            if isinstance(value, Vector):
                return self.assign_row(index, value)

        if isinstance(index, slice):
            # A[3:] = assign submatrix to rows
            if isinstance(value, Matrix):
                self.assign_matrix(value, index, None)
                return
            if isinstance(value, (bool, int, float, complex)):
                self.assign_scalar(value, index, None)
                return

        if isinstance(index, Matrix):
            if isinstance(value, Matrix):
                # A[M] = B masked matrix assignment
                raise NotImplementedError
            if not isinstance(value, (bool, int, float, complex)):
                raise TypeError
            # A[M] = s masked scalar assignment
            self.assign_scalar(value, mask=index)
            return

        if not isinstance(index, (tuple, list)):
            raise TypeError

        i0 = index[0]
        i1 = index[1]
        if isinstance(i0, int) and isinstance(i1, int):
            val = self.type.from_value(value)
            self._check(self.type.Matrix_setElement(self._matrix[0], val, i0, i1))
            return

        if isinstance(i0, int) and isinstance(i1, slice):
            # a[3,:] assign slice of row vector or scalar
            self.assign_row(i0, value, i1)
            return

        if isinstance(i0, slice) and isinstance(i1, int):
            # a[:,3] extract slice of col vector or scalar
            self.assign_col(i1, value, i0)
            return

        if isinstance(i0, slice) and isinstance(i1, slice):
            if isinstance(value, (bool, int, float, complex)):
                self.assign_scalar(value, i0, i1)
                return

            # a[:,:] assign submatrix
            self.assign_matrix(value, i0, i1)
            return

    def __delitem__(self, index):
        if (
            not isinstance(index, tuple)
            or not isinstance(index[0], int)
            or not isinstance(index[1], int)
        ):
            raise TypeError(
                &#34;__delitem__ currently only supports single element removal&#34;
            )
        self._check(lib.GrB_Matrix_removeElement(self._matrix[0], index[0], index[1]))

    def __contains__(self, index):
        try:
            v = self[index]
            return True
        except NoValue:
            return False

    def get(self, i, j, default=None):
        &#34;&#34;&#34;Get the element at row `i` col `j` or return the default value if
        the element is not present.

        &#34;&#34;&#34;
        try:
            return self[i, j]
        except NoValue:
            return default

    def wait(self):
        &#34;&#34;&#34;Wait for this Matrix to complete before allowing another thread to
        change it.

        &#34;&#34;&#34;
        self._check(lib.GrB_Matrix_wait(self._matrix))

    def to_string(self, format_string=&#34;{:&gt;%s}&#34;, width=3, empty_char=&#34;&#34;):
        &#34;&#34;&#34;Return a string representation of the Matrix.&#34;&#34;&#34;
        format_string = format_string % width
        header = (
            format_string.format(&#34;&#34;)
            + &#34; &#34;
            + &#34;&#34;.join(format_string.format(i) for i in range(self.ncols))
        )
        result = header + &#34;\n&#34;
        for row in range(self.nrows):
            result += format_string.format(row) + &#34;|&#34;
            for col in range(self.ncols):
                value = self.get(row, col, empty_char)
                result += self.type.format_value(value, width)
            result += &#34;|&#34; + format_string.format(row) + &#34;\n&#34;
        result += header

        return result

    def __str__(self):
        return self.to_string()

    def __repr__(self):
        return &#34;&lt;Matrix (%sx%s : %s:%s)&gt;&#34; % (
            self.nrows,
            self.ncols,
            self.nvals,
            self.type.__name__,
        )

    def to_scipy_sparse(self, format=&#34;csr&#34;):
        &#34;&#34;&#34;Return a scipy sparse matrix of this Matrix.&#34;&#34;&#34;
        from scipy import sparse

        rows, cols, vals = self.to_arrays()
        s = sparse.coo_matrix((vals, (rows, cols)), shape=self.shape)
        if format == &#34;coo&#34;:
            return s
        if format not in {&#34;bsr&#34;, &#34;csr&#34;, &#34;csc&#34;, &#34;coo&#34;, &#34;lil&#34;, &#34;dia&#34;, &#34;dok&#34;}:
            raise Exception(f&#34;Invalid format: {format}&#34;)
        return s.asformat(format)

    def to_numpy(self):
        &#34;&#34;&#34;Return a dense numpy matrix of this Matrix.&#34;&#34;&#34;
        s = self.to_scipy_sparse(&#34;coo&#34;)
        return s.toarray()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Types</h2>
<dl>
<dt id="pygraphblas.matrix.Matrix"><code class="flex name class">
<span>class <span class="ident">Matrix</span></span>
</code></dt>
<dd>
<div class="desc"><p>GraphBLAS Sparse Matrix</p>
<p>This is a high-level wrapper around the GrB_Matrix C type using
the <a href="https://cffi.readthedocs.io/en/latest/">cffi</a> library.</p>
<p>A Matrix supports many possible operations according to the
GraphBLAS API.
Many of those operations have overloaded
operators.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>A @
B</td>
<td>Matrix Matrix Multiplication</td>
<td>type default PLUS_TIMES semiring</td>
</tr>
<tr>
<td>v @
A</td>
<td>Vector Matrix Multiplication</td>
<td>type default PLUS_TIMES semiring</td>
</tr>
<tr>
<td>A @
v</td>
<td>Matrix Vector Multiplication</td>
<td>type default PLUS_TIMES semiring</td>
</tr>
<tr>
<td>A @=
B</td>
<td>In-place Matrix Matrix Multiplication</td>
<td>type default PLUS_TIMES semiring</td>
</tr>
<tr>
<td>v @=
A</td>
<td>In-place Vector Matrix Multiplication</td>
<td>type default PLUS_TIMES semiring</td>
</tr>
<tr>
<td>A @=
v</td>
<td>In-place Matrix Vector Multiplication</td>
<td>type default PLUS_TIMES semiring</td>
</tr>
<tr>
<td>A |
B</td>
<td>Matrix Union</td>
<td>type default SECOND combiner</td>
</tr>
<tr>
<td>A |= B</td>
<td>In-place Matrix Union</td>
<td>type default SECOND combiner</td>
</tr>
<tr>
<td>A &amp;
B</td>
<td>Matrix Intersection</td>
<td>type default SECOND combiner</td>
</tr>
<tr>
<td>A &amp;=
B</td>
<td>In-place Matrix Intersection</td>
<td>type default SECOND combiner</td>
</tr>
<tr>
<td>A +
B</td>
<td>Matrix Element-Wise Union</td>
<td>type default PLUS combiner</td>
</tr>
<tr>
<td>A +=
B</td>
<td>In-place Matrix Element-Wise Union</td>
<td>type default PLUS combiner</td>
</tr>
<tr>
<td>A -
B</td>
<td>Matrix Element-Wise Union</td>
<td>type default MINUS combiner</td>
</tr>
<tr>
<td>A -=
B</td>
<td>In-place Matrix Element-Wise Union</td>
<td>type default MINUS combiner</td>
</tr>
<tr>
<td>A *
B</td>
<td>Matrix Element-Wise Intersection</td>
<td>type default TIMES combiner</td>
</tr>
<tr>
<td>A *=
B</td>
<td>In-place Matrix Element-Wise Intersection</td>
<td>type default TIMES combiner</td>
</tr>
<tr>
<td>A /
B</td>
<td>Matrix Element-Wise Intersection</td>
<td>type default DIV combiner</td>
</tr>
<tr>
<td>A /=
B</td>
<td>In-place Matrix Element-Wise Intersection</td>
<td>type default DIV combiner</td>
</tr>
</tbody>
</table>
<p>Note that all the above operator syntax is mearly sugar over
various combinations of calling <code><a title="pygraphblas.matrix.Matrix.mxm" href="#pygraphblas.matrix.Matrix.mxm">Matrix.mxm()</a></code>, <code><a title="pygraphblas.matrix.Matrix.mxv" href="#pygraphblas.matrix.Matrix.mxv">Matrix.mxv()</a></code>,
<code><a title="pygraphblas.vector.Vector.vxm" href="vector.html#pygraphblas.vector.Vector.vxm">Vector.vxm()</a></code>, <code><a title="pygraphblas.matrix.Matrix.eadd" href="#pygraphblas.matrix.Matrix.eadd">Matrix.eadd()</a></code>, and <code><a title="pygraphblas.matrix.Matrix.emult" href="#pygraphblas.matrix.Matrix.emult">Matrix.emult()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Matrix:
    &#34;&#34;&#34;GraphBLAS Sparse Matrix

    This is a high-level wrapper around the GrB_Matrix C type using
    the [cffi](https://cffi.readthedocs.io/en/latest/) library.

    A Matrix supports many possible operations according to the
    GraphBLAS API.  Many of those operations have overloaded
    operators.

    Operator | Description | Default
    --- | --- | ---
    A @    B | Matrix Matrix Multiplication | type default PLUS_TIMES semiring
    v @    A | Vector Matrix Multiplication | type default PLUS_TIMES semiring
    A @    v | Matrix Vector Multiplication | type default PLUS_TIMES semiring
    A @=   B | In-place Matrix Matrix Multiplication | type default PLUS_TIMES semiring
    v @=   A | In-place Vector Matrix Multiplication | type default PLUS_TIMES semiring
    A @=   v | In-place Matrix Vector Multiplication | type default PLUS_TIMES semiring
    A \\|  B | Matrix Union | type default SECOND combiner
    A \\|= B | In-place Matrix Union | type default SECOND combiner
    A &amp;    B | Matrix Intersection | type default SECOND combiner
    A &amp;=   B | In-place Matrix Intersection | type default SECOND combiner
    A +    B | Matrix Element-Wise Union | type default PLUS combiner
    A +=   B | In-place Matrix Element-Wise Union | type default PLUS combiner
    A -    B | Matrix Element-Wise Union | type default MINUS combiner
    A -=   B | In-place Matrix Element-Wise Union | type default MINUS combiner
    A *    B | Matrix Element-Wise Intersection | type default TIMES combiner
    A *=   B | In-place Matrix Element-Wise Intersection | type default TIMES combiner
    A /    B | Matrix Element-Wise Intersection | type default DIV combiner
    A /=   B | In-place Matrix Element-Wise Intersection | type default DIV combiner

    Note that all the above operator syntax is mearly sugar over
    various combinations of calling `Matrix.mxm`, `Matrix.mxv`,
    `pygraphblas.vector.Vector.vxm`, `Matrix.eadd`, and `Matrix.emult`.

    &#34;&#34;&#34;

    __slots__ = (&#34;_matrix&#34;, &#34;type&#34;, &#34;_funcs&#34;, &#34;_keep_alives&#34;)

    def _check(self, res, raise_no_val=False):
        if res != lib.GrB_SUCCESS:
            if raise_no_val and res == lib.GrB_NO_VALUE:
                raise KeyError

            error_string = ffi.new(&#34;char**&#34;)
            lib.GrB_Matrix_error(error_string, self._matrix[0])
            raise _error_codes[res](ffi.string(error_string[0]))

    def __init__(self, matrix, typ=None):
        if typ is None:
            new_type = ffi.new(&#34;GrB_Type*&#34;)
            self._check(lib.GxB_Matrix_type(new_type, matrix[0]))

            typ = types.gb_type_to_type(new_type[0])

        self._matrix = matrix
        self.type = typ
        self._keep_alives = weakref.WeakKeyDictionary()

    def __del__(self):
        self._check(lib.GrB_Matrix_free(self._matrix))

    @classmethod
    def sparse(cls, typ, nrows=None, ncols=None):
        &#34;&#34;&#34;Create an empty sparse Matrix from the given type.  The dimensions
        can be specified with `nrows` and `ncols`.  If no dimensions
        are specified, they default to `pygraphblas.GxB_INDEX_MAX`.

        &gt;&gt;&gt; m = Matrix.sparse(types.UINT8)
        &gt;&gt;&gt; m.nrows == lib.GxB_INDEX_MAX
        True
        &gt;&gt;&gt; m.ncols == lib.GxB_INDEX_MAX
        True
        &gt;&gt;&gt; m.nvals == 0
        True

        Optional row and column dimension bounds can be provided to
        the method:

        &gt;&gt;&gt; m = Matrix.sparse(types.UINT8, 10, 10)
        &gt;&gt;&gt; m.nrows == 10
        True
        &gt;&gt;&gt; m.ncols == 10
        True
        &gt;&gt;&gt; m.nvals == 0
        True

        &#34;&#34;&#34;
        if nrows is None:
            nrows = GxB_INDEX_MAX
        if ncols is None:
            ncols = GxB_INDEX_MAX
        new_mat = ffi.new(&#34;GrB_Matrix*&#34;)
        _check(lib.GrB_Matrix_new(new_mat, typ.gb_type, nrows, ncols))
        m = cls(new_mat, typ)
        return m

    @classmethod
    def dense(cls, typ, nrows, ncols, fill=None, sparsity_control=None):
        &#34;&#34;&#34;Return a dense Matrix nrows by ncols.

        If `sparsity_control` is provided it is used for the new
        matrix (See SuiteSparse User Guide)

        &gt;&gt;&gt; m = Matrix.dense(types.UINT8, 3, 3)
        &gt;&gt;&gt; m.nrows == 3
        True
        &gt;&gt;&gt; m.ncols == 3
        True
        &gt;&gt;&gt; m.nvals == 9
        True
        &gt;&gt;&gt; for i, j, v in m:
        ...     assert v == 0

        If a `fill` value is present, use that, otherwise use the
        `zero` attribte of the given type.

        &gt;&gt;&gt; m = Matrix.dense(types.UINT8, 3, 3, fill=1)
        &gt;&gt;&gt; m.nrows == 3
        True
        &gt;&gt;&gt; m.ncols == 3
        True
        &gt;&gt;&gt; m.nvals == 9
        True
        &gt;&gt;&gt; for i, j, v in m:
        ...     assert v == 1

        &#34;&#34;&#34;
        assert nrows &gt; 0 and ncols &gt; 0, &#34;dense matrix must be at least 1x1&#34;
        m = cls.sparse(typ, nrows, ncols)
        if sparsity_control is not None:
            v.sparsity_control = sparsity_control
        if fill is None:
            fill = m.type.zero
        m[:, :] = fill
        return m

    @classmethod
    def from_lists(cls, I, J, V, nrows=None, ncols=None, typ=None):
        &#34;&#34;&#34;Create a new matrix from the given lists of row indices, column
        indices, and values.  If nrows or ncols are not provided, they
        are computed from the max values of the provides row and
        column indices lists.

        &gt;&gt;&gt; M = Matrix.from_lists([1, 2, 3], [2, 3, 1], [42, 314, 1492])
        &gt;&gt;&gt; g = draw(M, filename=&#39;/docs/imgs/Matrix_from_lists&#39;)

        ![Matrix_from_lists.png](../imgs/Matrix_from_lists.png)

        &#34;&#34;&#34;
        assert len(I) == len(J) == len(V)
        if not nrows:
            nrows = max(I) + 1
        if not ncols:
            ncols = max(J) + 1
        # TODO use ffi and GrB_Matrix_build
        if typ is None:
            typ = types._gb_from_type(type(V[0]))
        m = cls.sparse(typ, nrows, ncols)
        for i, j, v in zip(I, J, V):
            m[i, j] = v
        return m

    @classmethod
    def from_mm(cls, mm_file, typ):
        &#34;&#34;&#34;Create a new matrix by reading a Matrix Market file.&#34;&#34;&#34;
        m = ffi.new(&#34;GrB_Matrix*&#34;)
        i = cls(m, typ)
        _check(lib.LAGraph_mmread(m, mm_file))
        return i

    @classmethod
    def from_tsv(cls, tsv_file, typ, nrows, ncols):
        &#34;&#34;&#34;Create a new matrix by reading a tab separated value file.&#34;&#34;&#34;
        m = ffi.new(&#34;GrB_Matrix*&#34;)
        i = cls(m, typ)
        _check(lib.LAGraph_tsvread(m, tsv_file, typ.gb_type, nrows, ncols))
        return i

    @classmethod
    def from_binfile(cls, bin_file):
        &#34;&#34;&#34;Create a new matrix by reading a SuiteSparse specific binary file.&#34;&#34;&#34;
        m = ffi.new(&#34;GrB_Matrix*&#34;)
        _check(lib.LAGraph_binread(m, bin_file))
        return cls(m)

    @classmethod
    def random(
        cls,
        typ,
        nrows,
        ncols,
        nvals,
        make_pattern=False,
        make_symmetric=False,
        make_skew_symmetric=False,
        make_hermitian=True,
        no_diagonal=False,
        seed=None,
    ):
        &#34;&#34;&#34;Create a new random Matrix of the given type, number of rows,
        columns and values.  Other flags set additional properties the
        matrix will hold.

        &gt;&gt;&gt; M = Matrix.random(types.UINT8, 5, 5, 20, 
        ...                   make_symmetric=True, no_diagonal=True, seed=42)
        &gt;&gt;&gt; g = draw(M, filename=&#39;/docs/imgs/Matrix_random&#39;)

        ![Matrix_random.png](../imgs/Matrix_random.png)

        &#34;&#34;&#34;
        result = ffi.new(&#34;GrB_Matrix*&#34;)
        i = cls(result, typ)
        fseed = ffi.new(&#34;uint64_t*&#34;)
        if seed is None:
            seed = randint(0, sys.maxsize)
        fseed[0] = seed
        _check(
            lib.LAGraph_random(
                result,
                typ.gb_type,
                nrows,
                ncols,
                nvals,
                make_pattern,
                make_symmetric,
                make_skew_symmetric,
                make_hermitian,
                no_diagonal,
                fseed,
            )
        )
        return i

    @classmethod
    def identity(cls, typ, nrows, one=None):
        &#34;&#34;&#34;Return a new square identity Matrix of nrows with diagonal set to
        one.

        If one is None, use the default typ one value.
        &#34;&#34;&#34;
        result = cls.sparse(typ, nrows, nrows)
        if one is None:
            one = result.type.one
        for i in range(nrows):
            result[i, i] = one
        return result

    @property
    def gb_type(self):
        &#34;&#34;&#34;Return the GraphBLAS low-level type object of the Matrix.  This is
        only used if interacting with the low level API.

        &#34;&#34;&#34;
        new_type = ffi.new(&#34;GrB_Type*&#34;)
        self._check(lib.GxB_Matrix_type(new_type, self._matrix[0]))
        return new_type[0]

    @property
    def nrows(self):
        &#34;&#34;&#34;Return the number of Matrix rows.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.nrows
        3

        &#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Matrix_nrows(n, self._matrix[0]))
        return n[0]

    @property
    def ncols(self):
        &#34;&#34;&#34;Return the number of Matrix columns.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.ncols
        3

        &#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Matrix_ncols(n, self._matrix[0]))
        return n[0]

    @property
    def shape(self):
        &#34;&#34;&#34;Numpy-like description of matrix shape as 2-tuple (nrows, ncols).

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.shape
        (3, 3)

        &#34;&#34;&#34;
        return (self.nrows, self.ncols)

    @property
    def square(self):
        &#34;&#34;&#34;True if Matrix is square, else False.&#34;&#34;&#34;
        return self.nrows == self.ncols

    @property
    def nvals(self):
        &#34;&#34;&#34;Return the number of values stored in the Matrix.&#34;&#34;&#34;
        n = ffi.new(&#34;GrB_Index*&#34;)
        self._check(lib.GrB_Matrix_nvals(n, self._matrix[0]))
        return n[0]

    @property
    def T(self):
        &#34;&#34;&#34;Compute transpose of the Matrix.  See `Matrix.transpose`.

        Note: This property can be expensive, if you need the
        transpose more than once, consider storing this in a local
        variable.

        &#34;&#34;&#34;
        return self.transpose()

    def dup(self):
        &#34;&#34;&#34;Create an duplicate Matrix.

        &gt;&gt;&gt; A = Matrix.sparse(types.UINT8)
        &gt;&gt;&gt; A[1,1] = 42
        &gt;&gt;&gt; B = A.dup()
        &gt;&gt;&gt; B[1,1]
        42
        &gt;&gt;&gt; B is not A
        True

        &#34;&#34;&#34;
        new_mat = ffi.new(&#34;GrB_Matrix*&#34;)
        self._check(lib.GrB_Matrix_dup(new_mat, self._matrix[0]))
        return self.__class__(new_mat, self.type)

    @property
    def hyper_switch(self):
        &#34;&#34;&#34;Get the hyper_switch threshold. (See SuiteSparse User Guide)&#34;&#34;&#34;
        switch = ffi.new(&#34;double*&#34;)
        self._check(
            lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_HYPER_SWITCH, switch)
        )
        return switch[0]

    @hyper_switch.setter
    def hyper_switch(self, switch):
        &#34;&#34;&#34;Set the hyper_switch threshold. (See SuiteSparse User Guide)&#34;&#34;&#34;
        switch = ffi.cast(&#34;double&#34;, switch)
        self._check(
            lib.GxB_Matrix_Option_set(self._matrix[0], lib.GxB_HYPER_SWITCH, switch)
        )

    @property
    def format(self):
        &#34;&#34;&#34;Get Matrix format. (See SuiteSparse User Guide)&#34;&#34;&#34;
        format = ffi.new(&#34;GxB_Format_Value*&#34;)
        self._check(lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_FORMAT, format))
        return format[0]

    @format.setter
    def format(self, format):
        &#34;&#34;&#34;Set Matrix format. (See SuiteSparse User Guide)&#34;&#34;&#34;
        format = ffi.cast(&#34;GxB_Format_Value&#34;, format)
        self._check(lib.GxB_Matrix_Option_set(self._matrix[0], lib.GxB_FORMAT, format))

    @property
    def sparsity_control(self):
        &#34;&#34;&#34;Get Matrix sparsity control. (See SuiteSparse User Guide)&#34;&#34;&#34;
        sparsity = ffi.new(&#34;int*&#34;)
        self._check(
            lib.GxB_Matrix_Option_get(
                self._matrix[0], lib.GxB_SPARSITY_CONTROL, sparsity
            )
        )
        return sparsity[0]

    @sparsity_control.setter
    def sparsity_control(self, sparsity):
        &#34;&#34;&#34;Set Matrix sparsity control. (See SuiteSparse User Guide)&#34;&#34;&#34;
        sparsity = ffi.cast(&#34;int&#34;, sparsity)
        self._check(
            lib.GxB_Matrix_Option_set(
                self._matrix[0], lib.GxB_SPARSITY_CONTROL, sparsity
            )
        )

    @property
    def sparsity_status(self):
        &#34;&#34;&#34;Set Matrix sparsity status. (See SuiteSparse User Guide)&#34;&#34;&#34;
        status = ffi.new(&#34;int*&#34;)
        self._check(
            lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_SPARSITY_STATUS, status)
        )
        return status[0]

    def pattern(self, typ=types.BOOL):
        &#34;&#34;&#34;Return the pattern of the matrix where every present value in this
        matrix is set to identity value for the provided type which
        defaults to BOOL.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; P = M.pattern()
        &gt;&gt;&gt; P.type == types.BOOL
        True
        &gt;&gt;&gt; P[0,1]
        True

        &#34;&#34;&#34;

        r = ffi.new(&#34;GrB_Matrix*&#34;)
        self._check(lib.LAGraph_pattern(r, self._matrix[0], typ.gb_type))
        return Matrix(r, typ)

    def to_mm(self, fileobj):
        &#34;&#34;&#34;Write this matrix to a file using the Matrix Market format.&#34;&#34;&#34;
        self._check(lib.LAGraph_mmwrite(self._matrix[0], fileobj))

    def to_binfile(self, filename, comments=&#34;&#34;):
        &#34;&#34;&#34;Write this matrix using custom SuiteSparse binary format.&#34;&#34;&#34;
        self._check(
            lib.LAGraph_binwrite(self._matrix, filename, bytes(comments, &#34;utf8&#34;))
        )

    def to_lists(self):
        &#34;&#34;&#34;Extract the rows, columns and values of the Matrix as 3 lists.&#34;&#34;&#34;
        I = ffi.new(&#34;GrB_Index[%s]&#34; % self.nvals)
        J = ffi.new(&#34;GrB_Index[%s]&#34; % self.nvals)
        V = self.type.ffi.new(self.type.C + &#34;[%s]&#34; % self.nvals)
        n = ffi.new(&#34;GrB_Index*&#34;)
        n[0] = self.nvals
        self._check(self.type.Matrix_extractTuples(I, J, V, n, self._matrix[0]))
        return [list(I), list(J), list(map(self.type.to_value, V))]

    def clear(self):
        &#34;&#34;&#34;Clear the matrix.  This does not change the size but removes all
        values.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.nvals == 3
        True
        &gt;&gt;&gt; M.clear()
        &gt;&gt;&gt; M.nvals == 0
        True

        &#34;&#34;&#34;
        self._check(lib.GrB_Matrix_clear(self._matrix[0]))

    def resize(self, nrows, ncols):
        &#34;&#34;&#34;Resize the matrix.  If the dimensions decrease, entries that fall
        outside the resized matrix are deleted.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.shape
        (3, 3)
        &gt;&gt;&gt; M.resize(10, 10)
        &gt;&gt;&gt; M.shape
        (10, 10)

        &#34;&#34;&#34;
        self._check(lib.GrB_Matrix_resize(self._matrix[0], nrows, ncols))

    def transpose(self, cast=None, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Return Transpose of this matrix.

        This function can serve multiple interesting purposes
        including typecasting.  See the [SuiteSparse User
        Guide](https://raw.githubusercontent.com/DrTimothyAldenDavis/GraphBLAS/stable/Doc/GraphBLAS_UserGuide.pdf)

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; MT = M.transpose()
        &gt;&gt;&gt; MT.to_lists()
        [[0, 1, 2], [2, 0, 1], [1492, 42, 314]]

        &gt;&gt;&gt; MT = M.transpose(cast=types.BOOL, desc=descriptor.T0)
        &gt;&gt;&gt; MT.to_lists()
        [[0, 1, 2], [1, 2, 0], [True, True, True]]

        &#34;&#34;&#34;
        if out is None:
            new_dimensions = (
                (self.nrows, self.ncols)
                if TransposeA in desc
                else (self.ncols, self.nrows)
            )
            _out = ffi.new(&#34;GrB_Matrix*&#34;)
            if cast is not None:
                typ = cast
            else:
                typ = self.type
            self._check(lib.GrB_Matrix_new(_out, typ.gb_type, *new_dimensions))
            out = self.__class__(_out, typ)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(lib.GrB_transpose(out._matrix[0], mask, accum, self._matrix[0], desc))
        return out

    def cast(self, cast, out=None):
        &#34;&#34;&#34;Cast this matrix to the provided type.  If out is not provided, a
        new matrix is of the cast type is created.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; N = M.cast(types.BOOL)
        &gt;&gt;&gt; N.to_lists()
        [[0, 1, 2], [1, 2, 0], [True, True, True]]

        &#34;&#34;&#34;
        return self.transpose(cast, out, desc=TransposeA)

    def eadd(
        self,
        other,
        add_op=None,
        cast=None,
        out=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Element-wise addition with other matrix.

        Element-wise addition applies a binary operator element-wise
        on two matrices A and B, for all entries that appear in the
        set intersection of the patterns of A and B.  Other operators
        other than addition can be used.

        The pattern of the result of the element-wise addition is
        the set union of the pattern of A and B. Entries in neither in
        A nor in B do not appear in the result.

        The only difference between element-wise multiplication and
        addition is the pattern of the result, and what happens to
        entries outside the intersection. With multiplication the
        pattern of T is the intersection; with addition it is the set
        union. Entries outside the set intersection are dropped for
        multiplication, and kept for addition; in both cases the
        operator is only applied to those (and only those) entries in
        the intersection. Any binary operator can be used
        interchangeably for either operation.

        &#34;&#34;&#34;
        if add_op is None:
            add_op = current_binop.get(binaryop.PLUS)
        elif isinstance(add_op, str):
            add_op = _get_bin_op(add_op, self.type)

        add_op = add_op.get_binaryop(self.type, other.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if out is None:
            typ = cast or types.promote(self.type, other.type)
            _out = ffi.new(&#34;GrB_Matrix*&#34;)
            self._check(lib.GrB_Matrix_new(_out, typ.gb_type, self.nrows, self.ncols))
            out = Matrix(_out, typ)

        self._check(
            lib.GrB_Matrix_eWiseAdd_BinaryOp(
                out._matrix[0],
                mask,
                accum,
                add_op,
                self._matrix[0],
                other._matrix[0],
                desc,
            )
        )
        return out

    def emult(
        self,
        other,
        mult_op=None,
        cast=None,
        out=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Element-wise multiplication with other matrix.

        Element-wise multiplication applies a binary operator
        element-wise on two matrices A and B, for all entries that
        appear in the set intersection of the patterns of A and B.
        Other operators other than addition can be used.

        The pattern of the result of the element-wise multiplication
        is exactly this set intersection. Entries in A but not B, or
        visa versa, do not appear in the result.

        The only difference between element-wise multiplication and
        addition is the pattern of the result, and what happens to
        entries outside the intersection. With multiplication the
        pattern of T is the intersection; with addition it is the set
        union. Entries outside the set intersection are dropped for
        multiplication, and kept for addition; in both cases the
        operator is only applied to those (and only those) entries in
        the intersection. Any binary operator can be used
        interchangeably for either operation.

        &#34;&#34;&#34;
        if mult_op is None:
            mult_op = current_binop.get(binaryop.TIMES)
        elif isinstance(mult_op, str):
            mult_op = _get_bin_op(mult_op, self.type)

        mult_op = mult_op.get_binaryop(self.type, other.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if out is None:
            typ = cast or types.promote(self.type, other.type)
            _out = ffi.new(&#34;GrB_Matrix*&#34;)
            self._check(lib.GrB_Matrix_new(_out, typ.gb_type, self.nrows, self.ncols))
            out = Matrix(_out, typ)

        self._check(
            lib.GrB_Matrix_eWiseMult_BinaryOp(
                out._matrix[0],
                mask,
                accum,
                mult_op,
                self._matrix[0],
                other._matrix[0],
                desc,
            )
        )
        return out

    def iseq(self, other):
        &#34;&#34;&#34;Compare two matrices for equality returning True or False.  

        Not to be confused with `==` which will return a matrix of
        BOOL values comparing *elements* for equality.

        Uses code from LAGraph_isequal.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; N = M.dup()
        &gt;&gt;&gt; M.iseq(N)
        True
        &gt;&gt;&gt; del N[0, 1]
        &gt;&gt;&gt; M.iseq(N)
        False

        &#34;&#34;&#34;
        result = ffi.new(&#34;_Bool*&#34;)
        eq_op = self.type.EQ.get_binaryop(self.type, other.type)
        self._check(lib.LAGraph_isequal(result, self._matrix[0], other._matrix[0], eq_op))
        return result[0]

    def isne(self, other):
        &#34;&#34;&#34;Compare two matrices for inequality.  See `Matrix.iseq`.

        &#34;&#34;&#34;
        return not self.iseq(other)

    def __iter__(self):
        &#34;&#34;&#34;Iterate over the (row, col, value) triples of the Matrix.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; sorted(list(iter(M)))
        [(0, 1, 42), (1, 2, 314), (2, 0, 1492)]

        &#34;&#34;&#34;
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        J = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return zip(I, J, map(self.type.to_value, X))

    def to_arrays(self):
        &#34;&#34;&#34;Convert Matrix to tuple of three dense array objects.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; M.to_arrays()
        (array(&#39;L&#39;, [0, 1, 2]), array(&#39;L&#39;, [1, 2, 0]), array(&#39;q&#39;, [42, 314, 1492]))

        &#34;&#34;&#34;
        if self.type.typecode is None:
            raise TypeError(&#34;This matrix has no array typecode.&#34;)
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        J = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return array(&#34;L&#34;, I), array(&#34;L&#34;, J), array(self.type.typecode, X)

    @property
    def rows(self):
        &#34;&#34;&#34;An iterator of row indexes present in the matrix.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; list(M.rows)
        [0, 1, 2]

        &#34;&#34;&#34;
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        J = NULL
        X = NULL
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return iter(I)

    @property
    def cols(self):
        &#34;&#34;&#34;An iterator of column indexes present in the matrix.


        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; list(M.cols)
        [1, 2, 0]

        &#34;&#34;&#34;
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = NULL
        J = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
        X = NULL
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return iter(J)

    @property
    def vals(self):
        &#34;&#34;&#34;An iterator of values present in the matrix.


        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; list(M.vals)
        [42, 314, 1492]

        &#34;&#34;&#34;
        nvals = self.nvals
        _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
        I = NULL
        J = NULL
        X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
        self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
        return iter(X)

    def __len__(self):
        &#34;&#34;&#34;Return the number of elements in the Matrix.

        &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
        &gt;&gt;&gt; len(M)
        3

        &#34;&#34;&#34;
        return self.nvals

    def __and__(self, other):
        return self.emult(other, self.type.SECOND)

    def __iand__(self, other):
        return self.emult(other, self.type.SECOND, out=self)

    def __or__(self, other):
        return self.eadd(other, self.type.SECOND)

    def __ior__(self, other):
        return self.eadd(other, self.type.SECOND, out=self)

    def __add__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.PLUS, other)
        return self.eadd(other)

    def __radd__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_first(other, self.type.PLUS)
        return other.eadd(self)

    def __iadd__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.PLUS, other, out=self)
        return self.eadd(other, out=self)

    def __sub__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.MINUS, other)
        return self.eadd(other, add_op=self.type.MINUS)

    def __rsub__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_first(other, self.type.MINUS)
        return other.eadd(self, add_op=self.type.MINUS)

    def __isub__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.MINUS, other, out=self)
        return other.eadd(self, out=self, add_op=self.type.MINUS)

    def __mul__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.TIMES, other)
        return self.eadd(other, add_op=self.type.TIMES)

    def __rmul__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_first(other, self.type.TIMES)
        return other.eadd(self, add_op=self.type.TIMES)

    def __imul__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.TIMES, other)
        return other.eadd(self, out=self, add_op=self.type.TIMES)

    def __truediv__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.DIV, other)
        return self.eadd(other, add_op=self.type.DIV)

    def __rtruediv__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_first(other, self.type.DIV)
        return other.eadd(self, add_op=self.type.DIV)

    def __itruediv__(self, other):
        if not isinstance(other, Matrix):
            return self.apply_second(self.type.DIV, other)
        return other.eadd(self, out=self, add_op=self.type.DIV)

    def __invert__(self):
        return self.apply(unaryop.MINV)

    def __neg__(self):
        return self.apply(unaryop.AINV)

    def __abs__(self):
        return self.apply(unaryop.ABS)

    def __pow__(self, exponent):
        if exponent == 0:
            return self.__class__.identity(self.type, self.nrows)
        if exponent == 1:
            return self
        result = self.dup()
        for i in range(1, exponent):
            result.mxm(self, out=result)
        return result

    def reduce_bool(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce matrix to a boolean.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.BOOL.LOR_MONOID)
        mon = mon.get_monoid(self.type)
        result = ffi.new(&#34;_Bool*&#34;)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Matrix_reduce_BOOL(result, accum, mon, self._matrix[0], desc)
        )
        return result[0]

    def reduce_int(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce matrix to an integer.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(types.INT64.PLUS_MONOID)
        mon = mon.get_monoid(self.type)
        result = ffi.new(&#34;int64_t*&#34;)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Matrix_reduce_INT64(result, accum, mon, self._matrix[0], desc)
        )
        return result[0]

    def reduce_float(self, mon=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce matrix to an float.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(self.type.PLUS_MONOID)
        mon = mon.get_monoid(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        result = ffi.new(&#34;double*&#34;)
        self._check(
            lib.GrB_Matrix_reduce_FP64(result, accum, mon, self._matrix[0], desc)
        )
        return result[0]

    def reduce_vector(self, mon=None, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Reduce matrix to a vector.&#34;&#34;&#34;
        if mon is None:
            mon = current_monoid.get(getattr(self.type, &#34;PLUS_MONOID&#34;, NULL))
        mon = mon.get_monoid(self.type)
        if out is None:
            out = Vector.sparse(self.type, self.nrows)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Matrix_reduce_Monoid(
                out._vector[0], mask, accum, mon, self._matrix[0], desc
            )
        )
        return out

    def apply(self, op, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply Unary op to matrix elements.&#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if isinstance(op, UnaryOp):
            op = op.get_unaryop(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Matrix_apply(out._matrix[0], mask, accum, op, self._matrix[0], desc)
        )
        return out

    def apply_first(self, first, op, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply a binary operator to the entries in a matrix, binding the
        first input to a scalar first.

        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        if isinstance(first, Scalar):
            f = lib.GxB_Matrix_apply_BinaryOp1st
        else:
            f = self.type.Matrix_apply_BinaryOp1st
        self._check(f(out._matrix[0], mask, accum, op, first, self._matrix[0], desc))
        return out

    def apply_second(self, op, second, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Apply a binary operator to the entries in a matrix, binding the
        second input to a scalar second.

        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self.type)
        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            self.type.Matrix_apply_BinaryOp2nd(
                out._matrix[0], mask, accum, op, self._matrix[0], second, desc
            )
        )
        return out

    def select(self, op, thunk=None, out=None, mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Select elements that match the given select operation condition.
        Can be a string mapping to following operators:

            &#34;&gt;&#34;: lib.GxB_GT_THUNK
            &#34;&lt;&#34;: lib.GxB_LT_THUNK
            &#34;&gt;=&#34;: lib.GxB_GE_THUNK
            &#34;&lt;=&#34;: lib.GxB_LE_THUNK
            &#34;!=&#34;: lib.GxB_NE_THUNK
            &#34;==&#34;: lib.GxB_EQ_THUNK
            &#34;&gt;0&#34;: lib.GxB_GT_ZERO
            &#34;&lt;0&#34;: lib.GxB_LT_ZERO
            &#34;&gt;=0&#34;: lib.GxB_GE_ZERO
            &#34;&lt;=0&#34;: lib.GxB_LE_ZERO
            &#34;!=0&#34;: lib.GxB_NONZERO
            &#34;==0&#34;: lib.GxB_EQ_ZERO

        &#34;&#34;&#34;
        if out is None:
            out = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if isinstance(op, str):
            op = _get_select_op(op)

        if thunk is None:
            thunk = NULL
        if isinstance(thunk, (bool, int, float, complex)):
            thunk = Scalar.from_value(thunk)
        if isinstance(thunk, Scalar):
            self._keep_alives[self._matrix] = thunk
            thunk = thunk.scalar[0]

        mask, accum, desc = self._get_args(mask, accum, desc)

        self._check(
            lib.GxB_Matrix_select(
                out._matrix[0], mask, accum, op, self._matrix[0], thunk, desc
            )
        )
        return out

    def tril(self, thunk=None):
        &#34;&#34;&#34;Select the lower triangular Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_TRIL, thunk=thunk)

    def triu(self, thunk=None):
        &#34;&#34;&#34;Select the upper triangular Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_TRIU, thunk=thunk)

    def diag(self, thunk=None):
        &#34;&#34;&#34;Select the diagonal Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_DIAG, thunk=thunk)

    def offdiag(self, thunk=None):
        &#34;&#34;&#34;Select the off-diagonal Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_OFFDIAG, thunk=thunk)

    def nonzero(self):
        &#34;&#34;&#34;Select the non-zero Matrix.&#34;&#34;&#34;
        return self.select(lib.GxB_NONZERO)

    def _full(self, identity=None):
        &#34;&#34;&#34;&#34;&#34;&#34;
        B = self.__class__.sparse(self.type, self.nrows, self.ncols)
        if identity is None:
            identity = self.type.one

        self._check(
            self.type.Matrix_assignScalar(
                B._matrix[0], NULL, NULL, identity, lib.GrB_ALL, 0, lib.GrB_ALL, 0, NULL
            )
        )
        return self.eadd(B, self.type.FIRST)

    def _compare(self, other, op, strop):
        C = self.__class__.sparse(types.BOOL, self.nrows, self.ncols)
        if isinstance(other, (bool, int, float, complex)):
            if op(other, 0):
                B = self.__class__.dup(self)
                B[:, :] = other
                self.emult(B, strop, out=C)
                return C
            else:
                self.select(strop, other).apply(types.BOOL.ONE, out=C)
                return C
        elif isinstance(other, Matrix):
            A = self._full()
            B = other._full()
            A.emult(B, strop, out=C)
            return C
        else:
            raise TypeError(&#34;Unknown matrix comparison type.&#34;)

    def __gt__(self, other):
        return self._compare(other, operator.gt, &#34;&gt;&#34;)

    def __lt__(self, other):
        return self._compare(other, operator.lt, &#34;&lt;&#34;)

    def __ge__(self, other):
        return self._compare(other, operator.ge, &#34;&gt;=&#34;)

    def __le__(self, other):
        return self._compare(other, operator.le, &#34;&lt;=&#34;)

    def __eq__(self, other):
        return self._compare(other, operator.eq, &#34;==&#34;)

    def __ne__(self, other):
        return self._compare(other, operator.ne, &#34;!=&#34;)

    def _get_args(self, mask=None, accum=None, desc=Default):
        if isinstance(mask, Matrix):
            mask = mask._matrix[0]
        elif isinstance(mask, Vector):
            mask = mask._vector[0]
        else:
            mask = NULL
        if accum is None:
            accum = current_accum.get(NULL)
        if isinstance(accum, BinaryOp):
            accum = accum.get_binaryop(self.type)
        if desc is None or desc == Default:
            desc = current_desc.get(Default)
        if isinstance(desc, Descriptor):
            desc = desc.desc[0]
        return mask, accum, desc

    def mxm(
        self,
        other,
        cast=None,
        out=None,
        semiring=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Matrix-matrix multiply.&#34;&#34;&#34;
        if semiring is None:
            semiring = current_semiring.get(None)

        typ = cast or types.promote(self.type, other.type, semiring)
        if out is None:
            out = self.__class__.sparse(typ, self.nrows, other.ncols)

        if semiring is None:
            semiring = typ.PLUS_TIMES

        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_mxm(
                out._matrix[0],
                mask,
                accum,
                semiring.get_semiring(typ),
                self._matrix[0],
                other._matrix[0],
                desc,
            )
        )
        return out

    def mxv(
        self,
        other,
        cast=None,
        out=None,
        semiring=None,
        mask=None,
        accum=None,
        desc=Default,
    ):
        &#34;&#34;&#34;Matrix-vector multiply.&#34;&#34;&#34;
        if semiring is None:
            semiring = current_semiring.get(None)

        typ = cast or types.promote(self.type, other.type, semiring)
        if out is None:
            new_dimension = self.ncols if TransposeA in desc else self.nrows
            out = Vector.sparse(typ, new_dimension)

        mask, accum, desc = self._get_args(mask, accum, desc)
        if semiring is None:
            semiring = typ.PLUS_TIMES

        self._check(
            lib.GrB_mxv(
                out._vector[0],
                mask,
                accum,
                semiring.get_semiring(typ),
                self._matrix[0],
                other._vector[0],
                desc,
            )
        )
        return out

    def __matmul__(self, other):
        if isinstance(other, Matrix):
            return self.mxm(other)
        elif isinstance(other, Vector):
            return self.mxv(other)
        else:
            raise TypeError(&#34;Right argument to @ must be Matrix or Vector.&#34;)

    def __imatmul__(self, other):
        return self.mxm(other, out=self)

    def kronecker(self, other, op=None, cast=None, out=None,
                  mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Kronecker product.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        typ = cast or types.promote(self.type, other.type)
        if out is None:
            out = self.__class__.sparse(
                typ, self.nrows * other.nrows, self.ncols * other.ncols
            )
        if op is None:
            op = typ.TIMES
        if isinstance(op, BinaryOp):
            op = op.get_binaryop(self.type, other.type)

        self._check(
            lib.GrB_Matrix_kronecker_BinaryOp(
                out._matrix[0], mask, accum, op, self._matrix[0], other._matrix[0], desc
            )
        )
        return out

    def extract_matrix(self, rindex=None, cindex=None, out=None,
                       mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Extract a submatrix.&#34;&#34;&#34;
        ta = TransposeA in desc
        mask, accum, desc = self._get_args(mask, accum, desc)
        result_nrows = self.ncols if ta else self.nrows
        result_ncols = self.nrows if ta else self.ncols
        I, ni, isize = _build_range(rindex, result_nrows - 1)
        J, nj, jsize = _build_range(cindex, result_ncols - 1)
        if isize is None:
            isize = result_nrows
        if jsize is None:
            jsize = result_ncols

        if out is None:
            out = self.__class__.sparse(self.type, isize, jsize)

        self._check(
            lib.GrB_Matrix_extract(
                out._matrix[0], mask, accum, self._matrix[0], I, ni, J, nj, desc
            )
        )
        return out

    def extract_col(self, col_index, row_slice=None, out=None,
                    mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Extract a column Vector.&#34;&#34;&#34;
        stop_val = self.ncols if TransposeA in desc else self.nrows
        if out is None:
            out = Vector.sparse(self.type, stop_val)

        mask, accum, desc = self._get_args(mask, accum, desc)
        I, ni, size = _build_range(row_slice, stop_val)

        self._check(
            lib.GrB_Col_extract(
                out._vector[0], mask, accum, self._matrix[0], I, ni, col_index, desc
            )
        )
        return out

    def extract_row(self, row_index, col_slice=None, out=None,
                    mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Extract a row Vector.&#34;&#34;&#34;
        desc = desc | TransposeA
        return self.extract_col(
            row_index, col_slice, out, desc=desc, mask=None, accum=None
        )

    def __getitem__(self, index):
        if isinstance(index, int):
            # a[3] extract single row
            return self.extract_row(index, None)
        if isinstance(index, slice):
            # a[3:] extract submatrix of rows
            return self.extract_matrix(index, None)

        if isinstance(index, Matrix):
            return self.extract_matrix(mask=index)

        if not isinstance(index, (tuple, list)):
            raise TypeError

        i0 = index[0]
        i1 = index[1]
        if isinstance(i0, int) and isinstance(i1, int):
            # a[3,3] extract single element
            result = self.type.ffi.new(self.type.ptr)
            self._check(
                self.type.Matrix_extractElement(
                    result, self._matrix[0], index[0], index[1]
                )
            )
            return self.type.to_value(result[0])

        if isinstance(i0, int) and isinstance(i1, slice):
            # a[3,:] extract slice of row vector
            return self.extract_row(i0, i1)

        if isinstance(i0, slice) and isinstance(i1, int):
            # a[:,3] extract slice of col vector
            return self.extract_col(i1, i0)

        # a[:,:] or a[[0,1,2], [3,4,5]] extract submatrix with slice or row/col indices
        return self.extract_matrix(i0, i1)

    def assign_col(self, col_index, value, row_slice=None, mask=None,
                   accum=None, desc=Default):
        &#34;&#34;&#34;Assign a vector to a column.&#34;&#34;&#34;
        stop_val = self.ncols if TransposeA in desc else self.nrows
        I, ni, size = _build_range(row_slice, stop_val)
        mask, accum, desc = self._get_args(mask, accum, desc)

        self._check(
            lib.GrB_Col_assign(
                self._matrix[0], mask, accum, value._vector[0], I, ni, col_index, desc
            )
        )

    def assign_row(self, row_index, value, col_slice=None, mask=None,
                   accum=None, desc=Default):
        &#34;&#34;&#34;Assign a vector to a row.&#34;&#34;&#34;
        stop_val = self.nrows if TransposeA in desc else self.ncols
        I, ni, size = _build_range(col_slice, stop_val)

        mask, accum, desc = self._get_args(mask, accum, desc)
        self._check(
            lib.GrB_Row_assign(
                self._matrix[0], mask, accum, value._vector[0], row_index, I, ni, desc
            )
        )

    def assign_matrix(self, value, rindex=None, cindex=None,
                      mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Assign a submatrix.&#34;&#34;&#34;
        I, ni, isize = _build_range(rindex, self.nrows - 1)
        J, nj, jsize = _build_range(cindex, self.ncols - 1)
        if isize is None:
            isize = self.nrows
        if jsize is None:
            jsize = self.ncols

        mask, accum, desc = self._get_args(mask, accum, desc)

        self._check(
            lib.GrB_Matrix_assign(
                self._matrix[0], mask, accum, value._matrix[0], I, ni, J, nj, desc
            )
        )

    def assign_scalar(self, value, row_slice=None, col_slice=None,
                      mask=None, accum=None, desc=Default):
        &#34;&#34;&#34;Assign a scalar to the Matrix.&#34;&#34;&#34;
        mask, accum, desc = self._get_args(mask, accum, desc)
        if row_slice:
            I, ni, isize = _build_range(row_slice, self.nrows - 1)
        else:
            I = lib.GrB_ALL
            ni = 0
        if col_slice:
            J, nj, jsize = _build_range(col_slice, self.ncols - 1)
        else:
            J = lib.GrB_ALL
            nj = 0
        scalar_type = types._gb_from_type(type(value))
        self._check(
            scalar_type.Matrix_assignScalar(
                self._matrix[0], mask, accum, value, I, ni, J, nj, desc
            )
        )

    def __setitem__(self, index, value):
        if isinstance(index, int):
            # A[3] = assign single row  vector
            if isinstance(value, Vector):
                return self.assign_row(index, value)

        if isinstance(index, slice):
            # A[3:] = assign submatrix to rows
            if isinstance(value, Matrix):
                self.assign_matrix(value, index, None)
                return
            if isinstance(value, (bool, int, float, complex)):
                self.assign_scalar(value, index, None)
                return

        if isinstance(index, Matrix):
            if isinstance(value, Matrix):
                # A[M] = B masked matrix assignment
                raise NotImplementedError
            if not isinstance(value, (bool, int, float, complex)):
                raise TypeError
            # A[M] = s masked scalar assignment
            self.assign_scalar(value, mask=index)
            return

        if not isinstance(index, (tuple, list)):
            raise TypeError

        i0 = index[0]
        i1 = index[1]
        if isinstance(i0, int) and isinstance(i1, int):
            val = self.type.from_value(value)
            self._check(self.type.Matrix_setElement(self._matrix[0], val, i0, i1))
            return

        if isinstance(i0, int) and isinstance(i1, slice):
            # a[3,:] assign slice of row vector or scalar
            self.assign_row(i0, value, i1)
            return

        if isinstance(i0, slice) and isinstance(i1, int):
            # a[:,3] extract slice of col vector or scalar
            self.assign_col(i1, value, i0)
            return

        if isinstance(i0, slice) and isinstance(i1, slice):
            if isinstance(value, (bool, int, float, complex)):
                self.assign_scalar(value, i0, i1)
                return

            # a[:,:] assign submatrix
            self.assign_matrix(value, i0, i1)
            return

    def __delitem__(self, index):
        if (
            not isinstance(index, tuple)
            or not isinstance(index[0], int)
            or not isinstance(index[1], int)
        ):
            raise TypeError(
                &#34;__delitem__ currently only supports single element removal&#34;
            )
        self._check(lib.GrB_Matrix_removeElement(self._matrix[0], index[0], index[1]))

    def __contains__(self, index):
        try:
            v = self[index]
            return True
        except NoValue:
            return False

    def get(self, i, j, default=None):
        &#34;&#34;&#34;Get the element at row `i` col `j` or return the default value if
        the element is not present.

        &#34;&#34;&#34;
        try:
            return self[i, j]
        except NoValue:
            return default

    def wait(self):
        &#34;&#34;&#34;Wait for this Matrix to complete before allowing another thread to
        change it.

        &#34;&#34;&#34;
        self._check(lib.GrB_Matrix_wait(self._matrix))

    def to_string(self, format_string=&#34;{:&gt;%s}&#34;, width=3, empty_char=&#34;&#34;):
        &#34;&#34;&#34;Return a string representation of the Matrix.&#34;&#34;&#34;
        format_string = format_string % width
        header = (
            format_string.format(&#34;&#34;)
            + &#34; &#34;
            + &#34;&#34;.join(format_string.format(i) for i in range(self.ncols))
        )
        result = header + &#34;\n&#34;
        for row in range(self.nrows):
            result += format_string.format(row) + &#34;|&#34;
            for col in range(self.ncols):
                value = self.get(row, col, empty_char)
                result += self.type.format_value(value, width)
            result += &#34;|&#34; + format_string.format(row) + &#34;\n&#34;
        result += header

        return result

    def __str__(self):
        return self.to_string()

    def __repr__(self):
        return &#34;&lt;Matrix (%sx%s : %s:%s)&gt;&#34; % (
            self.nrows,
            self.ncols,
            self.nvals,
            self.type.__name__,
        )

    def to_scipy_sparse(self, format=&#34;csr&#34;):
        &#34;&#34;&#34;Return a scipy sparse matrix of this Matrix.&#34;&#34;&#34;
        from scipy import sparse

        rows, cols, vals = self.to_arrays()
        s = sparse.coo_matrix((vals, (rows, cols)), shape=self.shape)
        if format == &#34;coo&#34;:
            return s
        if format not in {&#34;bsr&#34;, &#34;csr&#34;, &#34;csc&#34;, &#34;coo&#34;, &#34;lil&#34;, &#34;dia&#34;, &#34;dok&#34;}:
            raise Exception(f&#34;Invalid format: {format}&#34;)
        return s.asformat(format)

    def to_numpy(self):
        &#34;&#34;&#34;Return a dense numpy matrix of this Matrix.&#34;&#34;&#34;
        s = self.to_scipy_sparse(&#34;coo&#34;)
        return s.toarray()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pygraphblas.matrix.Matrix.dense"><code class="name flex">
<span>def <span class="ident">dense</span></span>(<span>typ, nrows, ncols, fill=None, sparsity_control=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dense Matrix nrows by ncols.</p>
<p>If <code>sparsity_control</code> is provided it is used for the new
matrix (See SuiteSparse User Guide)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = Matrix.dense(types.UINT8, 3, 3)
&gt;&gt;&gt; m.nrows == 3
True
&gt;&gt;&gt; m.ncols == 3
True
&gt;&gt;&gt; m.nvals == 9
True
&gt;&gt;&gt; for i, j, v in m:
...     assert v == 0
</code></pre>
<p>If a <code>fill</code> value is present, use that, otherwise use the
<code>zero</code> attribte of the given type.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = Matrix.dense(types.UINT8, 3, 3, fill=1)
&gt;&gt;&gt; m.nrows == 3
True
&gt;&gt;&gt; m.ncols == 3
True
&gt;&gt;&gt; m.nvals == 9
True
&gt;&gt;&gt; for i, j, v in m:
...     assert v == 1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def dense(cls, typ, nrows, ncols, fill=None, sparsity_control=None):
    &#34;&#34;&#34;Return a dense Matrix nrows by ncols.

    If `sparsity_control` is provided it is used for the new
    matrix (See SuiteSparse User Guide)

    &gt;&gt;&gt; m = Matrix.dense(types.UINT8, 3, 3)
    &gt;&gt;&gt; m.nrows == 3
    True
    &gt;&gt;&gt; m.ncols == 3
    True
    &gt;&gt;&gt; m.nvals == 9
    True
    &gt;&gt;&gt; for i, j, v in m:
    ...     assert v == 0

    If a `fill` value is present, use that, otherwise use the
    `zero` attribte of the given type.

    &gt;&gt;&gt; m = Matrix.dense(types.UINT8, 3, 3, fill=1)
    &gt;&gt;&gt; m.nrows == 3
    True
    &gt;&gt;&gt; m.ncols == 3
    True
    &gt;&gt;&gt; m.nvals == 9
    True
    &gt;&gt;&gt; for i, j, v in m:
    ...     assert v == 1

    &#34;&#34;&#34;
    assert nrows &gt; 0 and ncols &gt; 0, &#34;dense matrix must be at least 1x1&#34;
    m = cls.sparse(typ, nrows, ncols)
    if sparsity_control is not None:
        v.sparsity_control = sparsity_control
    if fill is None:
        fill = m.type.zero
    m[:, :] = fill
    return m</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.from_binfile"><code class="name flex">
<span>def <span class="ident">from_binfile</span></span>(<span>bin_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new matrix by reading a SuiteSparse specific binary file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_binfile(cls, bin_file):
    &#34;&#34;&#34;Create a new matrix by reading a SuiteSparse specific binary file.&#34;&#34;&#34;
    m = ffi.new(&#34;GrB_Matrix*&#34;)
    _check(lib.LAGraph_binread(m, bin_file))
    return cls(m)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.from_lists"><code class="name flex">
<span>def <span class="ident">from_lists</span></span>(<span>I, J, V, nrows=None, ncols=None, typ=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new matrix from the given lists of row indices, column
indices, and values.
If nrows or ncols are not provided, they
are computed from the max values of the provides row and
column indices lists.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([1, 2, 3], [2, 3, 1], [42, 314, 1492])
&gt;&gt;&gt; g = draw(M, filename='/docs/imgs/Matrix_from_lists')
</code></pre>
<p><img alt="Matrix_from_lists.png" src="../imgs/Matrix_from_lists.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_lists(cls, I, J, V, nrows=None, ncols=None, typ=None):
    &#34;&#34;&#34;Create a new matrix from the given lists of row indices, column
    indices, and values.  If nrows or ncols are not provided, they
    are computed from the max values of the provides row and
    column indices lists.

    &gt;&gt;&gt; M = Matrix.from_lists([1, 2, 3], [2, 3, 1], [42, 314, 1492])
    &gt;&gt;&gt; g = draw(M, filename=&#39;/docs/imgs/Matrix_from_lists&#39;)

    ![Matrix_from_lists.png](../imgs/Matrix_from_lists.png)

    &#34;&#34;&#34;
    assert len(I) == len(J) == len(V)
    if not nrows:
        nrows = max(I) + 1
    if not ncols:
        ncols = max(J) + 1
    # TODO use ffi and GrB_Matrix_build
    if typ is None:
        typ = types._gb_from_type(type(V[0]))
    m = cls.sparse(typ, nrows, ncols)
    for i, j, v in zip(I, J, V):
        m[i, j] = v
    return m</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.from_mm"><code class="name flex">
<span>def <span class="ident">from_mm</span></span>(<span>mm_file, typ)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new matrix by reading a Matrix Market file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_mm(cls, mm_file, typ):
    &#34;&#34;&#34;Create a new matrix by reading a Matrix Market file.&#34;&#34;&#34;
    m = ffi.new(&#34;GrB_Matrix*&#34;)
    i = cls(m, typ)
    _check(lib.LAGraph_mmread(m, mm_file))
    return i</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.from_tsv"><code class="name flex">
<span>def <span class="ident">from_tsv</span></span>(<span>tsv_file, typ, nrows, ncols)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new matrix by reading a tab separated value file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_tsv(cls, tsv_file, typ, nrows, ncols):
    &#34;&#34;&#34;Create a new matrix by reading a tab separated value file.&#34;&#34;&#34;
    m = ffi.new(&#34;GrB_Matrix*&#34;)
    i = cls(m, typ)
    _check(lib.LAGraph_tsvread(m, tsv_file, typ.gb_type, nrows, ncols))
    return i</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.identity"><code class="name flex">
<span>def <span class="ident">identity</span></span>(<span>typ, nrows, one=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new square identity Matrix of nrows with diagonal set to
one.</p>
<p>If one is None, use the default typ one value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def identity(cls, typ, nrows, one=None):
    &#34;&#34;&#34;Return a new square identity Matrix of nrows with diagonal set to
    one.

    If one is None, use the default typ one value.
    &#34;&#34;&#34;
    result = cls.sparse(typ, nrows, nrows)
    if one is None:
        one = result.type.one
    for i in range(nrows):
        result[i, i] = one
    return result</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>typ, nrows, ncols, nvals, make_pattern=False, make_symmetric=False, make_skew_symmetric=False, make_hermitian=True, no_diagonal=False, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new random Matrix of the given type, number of rows,
columns and values.
Other flags set additional properties the
matrix will hold.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.random(types.UINT8, 5, 5, 20, 
...                   make_symmetric=True, no_diagonal=True, seed=42)
&gt;&gt;&gt; g = draw(M, filename='/docs/imgs/Matrix_random')
</code></pre>
<p><img alt="Matrix_random.png" src="../imgs/Matrix_random.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def random(
    cls,
    typ,
    nrows,
    ncols,
    nvals,
    make_pattern=False,
    make_symmetric=False,
    make_skew_symmetric=False,
    make_hermitian=True,
    no_diagonal=False,
    seed=None,
):
    &#34;&#34;&#34;Create a new random Matrix of the given type, number of rows,
    columns and values.  Other flags set additional properties the
    matrix will hold.

    &gt;&gt;&gt; M = Matrix.random(types.UINT8, 5, 5, 20, 
    ...                   make_symmetric=True, no_diagonal=True, seed=42)
    &gt;&gt;&gt; g = draw(M, filename=&#39;/docs/imgs/Matrix_random&#39;)

    ![Matrix_random.png](../imgs/Matrix_random.png)

    &#34;&#34;&#34;
    result = ffi.new(&#34;GrB_Matrix*&#34;)
    i = cls(result, typ)
    fseed = ffi.new(&#34;uint64_t*&#34;)
    if seed is None:
        seed = randint(0, sys.maxsize)
    fseed[0] = seed
    _check(
        lib.LAGraph_random(
            result,
            typ.gb_type,
            nrows,
            ncols,
            nvals,
            make_pattern,
            make_symmetric,
            make_skew_symmetric,
            make_hermitian,
            no_diagonal,
            fseed,
        )
    )
    return i</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.sparse"><code class="name flex">
<span>def <span class="ident">sparse</span></span>(<span>typ, nrows=None, ncols=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an empty sparse Matrix from the given type.
The dimensions
can be specified with <code>nrows</code> and <code>ncols</code>.
If no dimensions
are specified, they default to <code><a title="pygraphblas.GxB_INDEX_MAX" href="index.html#pygraphblas.GxB_INDEX_MAX">GxB_INDEX_MAX</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = Matrix.sparse(types.UINT8)
&gt;&gt;&gt; m.nrows == lib.GxB_INDEX_MAX
True
&gt;&gt;&gt; m.ncols == lib.GxB_INDEX_MAX
True
&gt;&gt;&gt; m.nvals == 0
True
</code></pre>
<p>Optional row and column dimension bounds can be provided to
the method:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = Matrix.sparse(types.UINT8, 10, 10)
&gt;&gt;&gt; m.nrows == 10
True
&gt;&gt;&gt; m.ncols == 10
True
&gt;&gt;&gt; m.nvals == 0
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def sparse(cls, typ, nrows=None, ncols=None):
    &#34;&#34;&#34;Create an empty sparse Matrix from the given type.  The dimensions
    can be specified with `nrows` and `ncols`.  If no dimensions
    are specified, they default to `pygraphblas.GxB_INDEX_MAX`.

    &gt;&gt;&gt; m = Matrix.sparse(types.UINT8)
    &gt;&gt;&gt; m.nrows == lib.GxB_INDEX_MAX
    True
    &gt;&gt;&gt; m.ncols == lib.GxB_INDEX_MAX
    True
    &gt;&gt;&gt; m.nvals == 0
    True

    Optional row and column dimension bounds can be provided to
    the method:

    &gt;&gt;&gt; m = Matrix.sparse(types.UINT8, 10, 10)
    &gt;&gt;&gt; m.nrows == 10
    True
    &gt;&gt;&gt; m.ncols == 10
    True
    &gt;&gt;&gt; m.nvals == 0
    True

    &#34;&#34;&#34;
    if nrows is None:
        nrows = GxB_INDEX_MAX
    if ncols is None:
        ncols = GxB_INDEX_MAX
    new_mat = ffi.new(&#34;GrB_Matrix*&#34;)
    _check(lib.GrB_Matrix_new(new_mat, typ.gb_type, nrows, ncols))
    m = cls(new_mat, typ)
    return m</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pygraphblas.matrix.Matrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"><p>Compute transpose of the Matrix.
See <code><a title="pygraphblas.matrix.Matrix.transpose" href="#pygraphblas.matrix.Matrix.transpose">Matrix.transpose()</a></code>.</p>
<p>Note: This property can be expensive, if you need the
transpose more than once, consider storing this in a local
variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def T(self):
    &#34;&#34;&#34;Compute transpose of the Matrix.  See `Matrix.transpose`.

    Note: This property can be expensive, if you need the
    transpose more than once, consider storing this in a local
    variable.

    &#34;&#34;&#34;
    return self.transpose()</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.cols"><code class="name">var <span class="ident">cols</span></code></dt>
<dd>
<div class="desc"><p>An iterator of column indexes present in the matrix.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; list(M.cols)
[1, 2, 0]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cols(self):
    &#34;&#34;&#34;An iterator of column indexes present in the matrix.


    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; list(M.cols)
    [1, 2, 0]

    &#34;&#34;&#34;
    nvals = self.nvals
    _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
    I = NULL
    J = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
    X = NULL
    self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
    return iter(J)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.format"><code class="name">var <span class="ident">format</span></code></dt>
<dd>
<div class="desc"><p>Get Matrix format. (See SuiteSparse User Guide)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def format(self):
    &#34;&#34;&#34;Get Matrix format. (See SuiteSparse User Guide)&#34;&#34;&#34;
    format = ffi.new(&#34;GxB_Format_Value*&#34;)
    self._check(lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_FORMAT, format))
    return format[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.gb_type"><code class="name">var <span class="ident">gb_type</span></code></dt>
<dd>
<div class="desc"><p>Return the GraphBLAS low-level type object of the Matrix.
This is
only used if interacting with the low level API.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gb_type(self):
    &#34;&#34;&#34;Return the GraphBLAS low-level type object of the Matrix.  This is
    only used if interacting with the low level API.

    &#34;&#34;&#34;
    new_type = ffi.new(&#34;GrB_Type*&#34;)
    self._check(lib.GxB_Matrix_type(new_type, self._matrix[0]))
    return new_type[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.hyper_switch"><code class="name">var <span class="ident">hyper_switch</span></code></dt>
<dd>
<div class="desc"><p>Get the hyper_switch threshold. (See SuiteSparse User Guide)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hyper_switch(self):
    &#34;&#34;&#34;Get the hyper_switch threshold. (See SuiteSparse User Guide)&#34;&#34;&#34;
    switch = ffi.new(&#34;double*&#34;)
    self._check(
        lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_HYPER_SWITCH, switch)
    )
    return switch[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.ncols"><code class="name">var <span class="ident">ncols</span></code></dt>
<dd>
<div class="desc"><p>Return the number of Matrix columns.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; M.ncols
3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ncols(self):
    &#34;&#34;&#34;Return the number of Matrix columns.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; M.ncols
    3

    &#34;&#34;&#34;
    n = ffi.new(&#34;GrB_Index*&#34;)
    self._check(lib.GrB_Matrix_ncols(n, self._matrix[0]))
    return n[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.nrows"><code class="name">var <span class="ident">nrows</span></code></dt>
<dd>
<div class="desc"><p>Return the number of Matrix rows.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; M.nrows
3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nrows(self):
    &#34;&#34;&#34;Return the number of Matrix rows.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; M.nrows
    3

    &#34;&#34;&#34;
    n = ffi.new(&#34;GrB_Index*&#34;)
    self._check(lib.GrB_Matrix_nrows(n, self._matrix[0]))
    return n[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.nvals"><code class="name">var <span class="ident">nvals</span></code></dt>
<dd>
<div class="desc"><p>Return the number of values stored in the Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nvals(self):
    &#34;&#34;&#34;Return the number of values stored in the Matrix.&#34;&#34;&#34;
    n = ffi.new(&#34;GrB_Index*&#34;)
    self._check(lib.GrB_Matrix_nvals(n, self._matrix[0]))
    return n[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.rows"><code class="name">var <span class="ident">rows</span></code></dt>
<dd>
<div class="desc"><p>An iterator of row indexes present in the matrix.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; list(M.rows)
[0, 1, 2]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rows(self):
    &#34;&#34;&#34;An iterator of row indexes present in the matrix.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; list(M.rows)
    [0, 1, 2]

    &#34;&#34;&#34;
    nvals = self.nvals
    _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
    I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
    J = NULL
    X = NULL
    self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
    return iter(I)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Numpy-like description of matrix shape as 2-tuple (nrows, ncols).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; M.shape
(3, 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    &#34;&#34;&#34;Numpy-like description of matrix shape as 2-tuple (nrows, ncols).

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; M.shape
    (3, 3)

    &#34;&#34;&#34;
    return (self.nrows, self.ncols)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.sparsity_control"><code class="name">var <span class="ident">sparsity_control</span></code></dt>
<dd>
<div class="desc"><p>Get Matrix sparsity control. (See SuiteSparse User Guide)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sparsity_control(self):
    &#34;&#34;&#34;Get Matrix sparsity control. (See SuiteSparse User Guide)&#34;&#34;&#34;
    sparsity = ffi.new(&#34;int*&#34;)
    self._check(
        lib.GxB_Matrix_Option_get(
            self._matrix[0], lib.GxB_SPARSITY_CONTROL, sparsity
        )
    )
    return sparsity[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.sparsity_status"><code class="name">var <span class="ident">sparsity_status</span></code></dt>
<dd>
<div class="desc"><p>Set Matrix sparsity status. (See SuiteSparse User Guide)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sparsity_status(self):
    &#34;&#34;&#34;Set Matrix sparsity status. (See SuiteSparse User Guide)&#34;&#34;&#34;
    status = ffi.new(&#34;int*&#34;)
    self._check(
        lib.GxB_Matrix_Option_get(self._matrix[0], lib.GxB_SPARSITY_STATUS, status)
    )
    return status[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.square"><code class="name">var <span class="ident">square</span></code></dt>
<dd>
<div class="desc"><p>True if Matrix is square, else False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def square(self):
    &#34;&#34;&#34;True if Matrix is square, else False.&#34;&#34;&#34;
    return self.nrows == self.ncols</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pygraphblas.matrix.Matrix.vals"><code class="name">var <span class="ident">vals</span></code></dt>
<dd>
<div class="desc"><p>An iterator of values present in the matrix.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; list(M.vals)
[42, 314, 1492]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vals(self):
    &#34;&#34;&#34;An iterator of values present in the matrix.


    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; list(M.vals)
    [42, 314, 1492]

    &#34;&#34;&#34;
    nvals = self.nvals
    _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
    I = NULL
    J = NULL
    X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
    self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
    return iter(X)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygraphblas.matrix.Matrix.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, op, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply Unary op to matrix elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, op, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Apply Unary op to matrix elements.&#34;&#34;&#34;
    if out is None:
        out = self.__class__.sparse(self.type, self.nrows, self.ncols)
    if isinstance(op, UnaryOp):
        op = op.get_unaryop(self.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        lib.GrB_Matrix_apply(out._matrix[0], mask, accum, op, self._matrix[0], desc)
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.apply_first"><code class="name flex">
<span>def <span class="ident">apply_first</span></span>(<span>self, first, op, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a binary operator to the entries in a matrix, binding the
first input to a scalar first.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_first(self, first, op, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Apply a binary operator to the entries in a matrix, binding the
    first input to a scalar first.

    &#34;&#34;&#34;
    if out is None:
        out = self.__class__.sparse(self.type, self.nrows, self.ncols)
    if isinstance(op, BinaryOp):
        op = op.get_binaryop(self.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    if isinstance(first, Scalar):
        f = lib.GxB_Matrix_apply_BinaryOp1st
    else:
        f = self.type.Matrix_apply_BinaryOp1st
    self._check(f(out._matrix[0], mask, accum, op, first, self._matrix[0], desc))
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.apply_second"><code class="name flex">
<span>def <span class="ident">apply_second</span></span>(<span>self, op, second, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a binary operator to the entries in a matrix, binding the
second input to a scalar second.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_second(self, op, second, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Apply a binary operator to the entries in a matrix, binding the
    second input to a scalar second.

    &#34;&#34;&#34;
    if out is None:
        out = self.__class__.sparse(self.type, self.nrows, self.ncols)
    if isinstance(op, BinaryOp):
        op = op.get_binaryop(self.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        self.type.Matrix_apply_BinaryOp2nd(
            out._matrix[0], mask, accum, op, self._matrix[0], second, desc
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.assign_col"><code class="name flex">
<span>def <span class="ident">assign_col</span></span>(<span>self, col_index, value, row_slice=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign a vector to a column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_col(self, col_index, value, row_slice=None, mask=None,
               accum=None, desc=Default):
    &#34;&#34;&#34;Assign a vector to a column.&#34;&#34;&#34;
    stop_val = self.ncols if TransposeA in desc else self.nrows
    I, ni, size = _build_range(row_slice, stop_val)
    mask, accum, desc = self._get_args(mask, accum, desc)

    self._check(
        lib.GrB_Col_assign(
            self._matrix[0], mask, accum, value._vector[0], I, ni, col_index, desc
        )
    )</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.assign_matrix"><code class="name flex">
<span>def <span class="ident">assign_matrix</span></span>(<span>self, value, rindex=None, cindex=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign a submatrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_matrix(self, value, rindex=None, cindex=None,
                  mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Assign a submatrix.&#34;&#34;&#34;
    I, ni, isize = _build_range(rindex, self.nrows - 1)
    J, nj, jsize = _build_range(cindex, self.ncols - 1)
    if isize is None:
        isize = self.nrows
    if jsize is None:
        jsize = self.ncols

    mask, accum, desc = self._get_args(mask, accum, desc)

    self._check(
        lib.GrB_Matrix_assign(
            self._matrix[0], mask, accum, value._matrix[0], I, ni, J, nj, desc
        )
    )</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.assign_row"><code class="name flex">
<span>def <span class="ident">assign_row</span></span>(<span>self, row_index, value, col_slice=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign a vector to a row.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_row(self, row_index, value, col_slice=None, mask=None,
               accum=None, desc=Default):
    &#34;&#34;&#34;Assign a vector to a row.&#34;&#34;&#34;
    stop_val = self.nrows if TransposeA in desc else self.ncols
    I, ni, size = _build_range(col_slice, stop_val)

    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        lib.GrB_Row_assign(
            self._matrix[0], mask, accum, value._vector[0], row_index, I, ni, desc
        )
    )</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.assign_scalar"><code class="name flex">
<span>def <span class="ident">assign_scalar</span></span>(<span>self, value, row_slice=None, col_slice=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign a scalar to the Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_scalar(self, value, row_slice=None, col_slice=None,
                  mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Assign a scalar to the Matrix.&#34;&#34;&#34;
    mask, accum, desc = self._get_args(mask, accum, desc)
    if row_slice:
        I, ni, isize = _build_range(row_slice, self.nrows - 1)
    else:
        I = lib.GrB_ALL
        ni = 0
    if col_slice:
        J, nj, jsize = _build_range(col_slice, self.ncols - 1)
    else:
        J = lib.GrB_ALL
        nj = 0
    scalar_type = types._gb_from_type(type(value))
    self._check(
        scalar_type.Matrix_assignScalar(
            self._matrix[0], mask, accum, value, I, ni, J, nj, desc
        )
    )</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>self, cast, out=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Cast this matrix to the provided type.
If out is not provided, a
new matrix is of the cast type is created.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; N = M.cast(types.BOOL)
&gt;&gt;&gt; N.to_lists()
[[0, 1, 2], [1, 2, 0], [True, True, True]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cast(self, cast, out=None):
    &#34;&#34;&#34;Cast this matrix to the provided type.  If out is not provided, a
    new matrix is of the cast type is created.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; N = M.cast(types.BOOL)
    &gt;&gt;&gt; N.to_lists()
    [[0, 1, 2], [1, 2, 0], [True, True, True]]

    &#34;&#34;&#34;
    return self.transpose(cast, out, desc=TransposeA)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the matrix.
This does not change the size but removes all
values.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; M.nvals == 3
True
&gt;&gt;&gt; M.clear()
&gt;&gt;&gt; M.nvals == 0
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Clear the matrix.  This does not change the size but removes all
    values.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; M.nvals == 3
    True
    &gt;&gt;&gt; M.clear()
    &gt;&gt;&gt; M.nvals == 0
    True

    &#34;&#34;&#34;
    self._check(lib.GrB_Matrix_clear(self._matrix[0]))</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.diag"><code class="name flex">
<span>def <span class="ident">diag</span></span>(<span>self, thunk=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the diagonal Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diag(self, thunk=None):
    &#34;&#34;&#34;Select the diagonal Matrix.&#34;&#34;&#34;
    return self.select(lib.GxB_DIAG, thunk=thunk)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.dup"><code class="name flex">
<span>def <span class="ident">dup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an duplicate Matrix.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; A = Matrix.sparse(types.UINT8)
&gt;&gt;&gt; A[1,1] = 42
&gt;&gt;&gt; B = A.dup()
&gt;&gt;&gt; B[1,1]
42
&gt;&gt;&gt; B is not A
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dup(self):
    &#34;&#34;&#34;Create an duplicate Matrix.

    &gt;&gt;&gt; A = Matrix.sparse(types.UINT8)
    &gt;&gt;&gt; A[1,1] = 42
    &gt;&gt;&gt; B = A.dup()
    &gt;&gt;&gt; B[1,1]
    42
    &gt;&gt;&gt; B is not A
    True

    &#34;&#34;&#34;
    new_mat = ffi.new(&#34;GrB_Matrix*&#34;)
    self._check(lib.GrB_Matrix_dup(new_mat, self._matrix[0]))
    return self.__class__(new_mat, self.type)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.eadd"><code class="name flex">
<span>def <span class="ident">eadd</span></span>(<span>self, other, add_op=None, cast=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Element-wise addition with other matrix.</p>
<p>Element-wise addition applies a binary operator element-wise
on two matrices A and B, for all entries that appear in the
set intersection of the patterns of A and B.
Other operators
other than addition can be used.</p>
<p>The pattern of the result of the element-wise addition is
the set union of the pattern of A and B. Entries in neither in
A nor in B do not appear in the result.</p>
<p>The only difference between element-wise multiplication and
addition is the pattern of the result, and what happens to
entries outside the intersection. With multiplication the
pattern of T is the intersection; with addition it is the set
union. Entries outside the set intersection are dropped for
multiplication, and kept for addition; in both cases the
operator is only applied to those (and only those) entries in
the intersection. Any binary operator can be used
interchangeably for either operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eadd(
    self,
    other,
    add_op=None,
    cast=None,
    out=None,
    mask=None,
    accum=None,
    desc=Default,
):
    &#34;&#34;&#34;Element-wise addition with other matrix.

    Element-wise addition applies a binary operator element-wise
    on two matrices A and B, for all entries that appear in the
    set intersection of the patterns of A and B.  Other operators
    other than addition can be used.

    The pattern of the result of the element-wise addition is
    the set union of the pattern of A and B. Entries in neither in
    A nor in B do not appear in the result.

    The only difference between element-wise multiplication and
    addition is the pattern of the result, and what happens to
    entries outside the intersection. With multiplication the
    pattern of T is the intersection; with addition it is the set
    union. Entries outside the set intersection are dropped for
    multiplication, and kept for addition; in both cases the
    operator is only applied to those (and only those) entries in
    the intersection. Any binary operator can be used
    interchangeably for either operation.

    &#34;&#34;&#34;
    if add_op is None:
        add_op = current_binop.get(binaryop.PLUS)
    elif isinstance(add_op, str):
        add_op = _get_bin_op(add_op, self.type)

    add_op = add_op.get_binaryop(self.type, other.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    if out is None:
        typ = cast or types.promote(self.type, other.type)
        _out = ffi.new(&#34;GrB_Matrix*&#34;)
        self._check(lib.GrB_Matrix_new(_out, typ.gb_type, self.nrows, self.ncols))
        out = Matrix(_out, typ)

    self._check(
        lib.GrB_Matrix_eWiseAdd_BinaryOp(
            out._matrix[0],
            mask,
            accum,
            add_op,
            self._matrix[0],
            other._matrix[0],
            desc,
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.emult"><code class="name flex">
<span>def <span class="ident">emult</span></span>(<span>self, other, mult_op=None, cast=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Element-wise multiplication with other matrix.</p>
<p>Element-wise multiplication applies a binary operator
element-wise on two matrices A and B, for all entries that
appear in the set intersection of the patterns of A and B.
Other operators other than addition can be used.</p>
<p>The pattern of the result of the element-wise multiplication
is exactly this set intersection. Entries in A but not B, or
visa versa, do not appear in the result.</p>
<p>The only difference between element-wise multiplication and
addition is the pattern of the result, and what happens to
entries outside the intersection. With multiplication the
pattern of T is the intersection; with addition it is the set
union. Entries outside the set intersection are dropped for
multiplication, and kept for addition; in both cases the
operator is only applied to those (and only those) entries in
the intersection. Any binary operator can be used
interchangeably for either operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emult(
    self,
    other,
    mult_op=None,
    cast=None,
    out=None,
    mask=None,
    accum=None,
    desc=Default,
):
    &#34;&#34;&#34;Element-wise multiplication with other matrix.

    Element-wise multiplication applies a binary operator
    element-wise on two matrices A and B, for all entries that
    appear in the set intersection of the patterns of A and B.
    Other operators other than addition can be used.

    The pattern of the result of the element-wise multiplication
    is exactly this set intersection. Entries in A but not B, or
    visa versa, do not appear in the result.

    The only difference between element-wise multiplication and
    addition is the pattern of the result, and what happens to
    entries outside the intersection. With multiplication the
    pattern of T is the intersection; with addition it is the set
    union. Entries outside the set intersection are dropped for
    multiplication, and kept for addition; in both cases the
    operator is only applied to those (and only those) entries in
    the intersection. Any binary operator can be used
    interchangeably for either operation.

    &#34;&#34;&#34;
    if mult_op is None:
        mult_op = current_binop.get(binaryop.TIMES)
    elif isinstance(mult_op, str):
        mult_op = _get_bin_op(mult_op, self.type)

    mult_op = mult_op.get_binaryop(self.type, other.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    if out is None:
        typ = cast or types.promote(self.type, other.type)
        _out = ffi.new(&#34;GrB_Matrix*&#34;)
        self._check(lib.GrB_Matrix_new(_out, typ.gb_type, self.nrows, self.ncols))
        out = Matrix(_out, typ)

    self._check(
        lib.GrB_Matrix_eWiseMult_BinaryOp(
            out._matrix[0],
            mask,
            accum,
            mult_op,
            self._matrix[0],
            other._matrix[0],
            desc,
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.extract_col"><code class="name flex">
<span>def <span class="ident">extract_col</span></span>(<span>self, col_index, row_slice=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a column Vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_col(self, col_index, row_slice=None, out=None,
                mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Extract a column Vector.&#34;&#34;&#34;
    stop_val = self.ncols if TransposeA in desc else self.nrows
    if out is None:
        out = Vector.sparse(self.type, stop_val)

    mask, accum, desc = self._get_args(mask, accum, desc)
    I, ni, size = _build_range(row_slice, stop_val)

    self._check(
        lib.GrB_Col_extract(
            out._vector[0], mask, accum, self._matrix[0], I, ni, col_index, desc
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.extract_matrix"><code class="name flex">
<span>def <span class="ident">extract_matrix</span></span>(<span>self, rindex=None, cindex=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a submatrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_matrix(self, rindex=None, cindex=None, out=None,
                   mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Extract a submatrix.&#34;&#34;&#34;
    ta = TransposeA in desc
    mask, accum, desc = self._get_args(mask, accum, desc)
    result_nrows = self.ncols if ta else self.nrows
    result_ncols = self.nrows if ta else self.ncols
    I, ni, isize = _build_range(rindex, result_nrows - 1)
    J, nj, jsize = _build_range(cindex, result_ncols - 1)
    if isize is None:
        isize = result_nrows
    if jsize is None:
        jsize = result_ncols

    if out is None:
        out = self.__class__.sparse(self.type, isize, jsize)

    self._check(
        lib.GrB_Matrix_extract(
            out._matrix[0], mask, accum, self._matrix[0], I, ni, J, nj, desc
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.extract_row"><code class="name flex">
<span>def <span class="ident">extract_row</span></span>(<span>self, row_index, col_slice=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a row Vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_row(self, row_index, col_slice=None, out=None,
                mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Extract a row Vector.&#34;&#34;&#34;
    desc = desc | TransposeA
    return self.extract_col(
        row_index, col_slice, out, desc=desc, mask=None, accum=None
    )</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, i, j, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the element at row <code>i</code> col <code>j</code> or return the default value if
the element is not present.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, i, j, default=None):
    &#34;&#34;&#34;Get the element at row `i` col `j` or return the default value if
    the element is not present.

    &#34;&#34;&#34;
    try:
        return self[i, j]
    except NoValue:
        return default</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.iseq"><code class="name flex">
<span>def <span class="ident">iseq</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare two matrices for equality returning True or False.
</p>
<p>Not to be confused with <code>==</code> which will return a matrix of
BOOL values comparing <em>elements</em> for equality.</p>
<p>Uses code from LAGraph_isequal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; N = M.dup()
&gt;&gt;&gt; M.iseq(N)
True
&gt;&gt;&gt; del N[0, 1]
&gt;&gt;&gt; M.iseq(N)
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iseq(self, other):
    &#34;&#34;&#34;Compare two matrices for equality returning True or False.  

    Not to be confused with `==` which will return a matrix of
    BOOL values comparing *elements* for equality.

    Uses code from LAGraph_isequal.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; N = M.dup()
    &gt;&gt;&gt; M.iseq(N)
    True
    &gt;&gt;&gt; del N[0, 1]
    &gt;&gt;&gt; M.iseq(N)
    False

    &#34;&#34;&#34;
    result = ffi.new(&#34;_Bool*&#34;)
    eq_op = self.type.EQ.get_binaryop(self.type, other.type)
    self._check(lib.LAGraph_isequal(result, self._matrix[0], other._matrix[0], eq_op))
    return result[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.isne"><code class="name flex">
<span>def <span class="ident">isne</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare two matrices for inequality.
See <code><a title="pygraphblas.matrix.Matrix.iseq" href="#pygraphblas.matrix.Matrix.iseq">Matrix.iseq()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isne(self, other):
    &#34;&#34;&#34;Compare two matrices for inequality.  See `Matrix.iseq`.

    &#34;&#34;&#34;
    return not self.iseq(other)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.kronecker"><code class="name flex">
<span>def <span class="ident">kronecker</span></span>(<span>self, other, op=None, cast=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Kronecker product.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kronecker(self, other, op=None, cast=None, out=None,
              mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Kronecker product.&#34;&#34;&#34;
    mask, accum, desc = self._get_args(mask, accum, desc)
    typ = cast or types.promote(self.type, other.type)
    if out is None:
        out = self.__class__.sparse(
            typ, self.nrows * other.nrows, self.ncols * other.ncols
        )
    if op is None:
        op = typ.TIMES
    if isinstance(op, BinaryOp):
        op = op.get_binaryop(self.type, other.type)

    self._check(
        lib.GrB_Matrix_kronecker_BinaryOp(
            out._matrix[0], mask, accum, op, self._matrix[0], other._matrix[0], desc
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.mxm"><code class="name flex">
<span>def <span class="ident">mxm</span></span>(<span>self, other, cast=None, out=None, semiring=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Matrix-matrix multiply.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mxm(
    self,
    other,
    cast=None,
    out=None,
    semiring=None,
    mask=None,
    accum=None,
    desc=Default,
):
    &#34;&#34;&#34;Matrix-matrix multiply.&#34;&#34;&#34;
    if semiring is None:
        semiring = current_semiring.get(None)

    typ = cast or types.promote(self.type, other.type, semiring)
    if out is None:
        out = self.__class__.sparse(typ, self.nrows, other.ncols)

    if semiring is None:
        semiring = typ.PLUS_TIMES

    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        lib.GrB_mxm(
            out._matrix[0],
            mask,
            accum,
            semiring.get_semiring(typ),
            self._matrix[0],
            other._matrix[0],
            desc,
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.mxv"><code class="name flex">
<span>def <span class="ident">mxv</span></span>(<span>self, other, cast=None, out=None, semiring=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Matrix-vector multiply.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mxv(
    self,
    other,
    cast=None,
    out=None,
    semiring=None,
    mask=None,
    accum=None,
    desc=Default,
):
    &#34;&#34;&#34;Matrix-vector multiply.&#34;&#34;&#34;
    if semiring is None:
        semiring = current_semiring.get(None)

    typ = cast or types.promote(self.type, other.type, semiring)
    if out is None:
        new_dimension = self.ncols if TransposeA in desc else self.nrows
        out = Vector.sparse(typ, new_dimension)

    mask, accum, desc = self._get_args(mask, accum, desc)
    if semiring is None:
        semiring = typ.PLUS_TIMES

    self._check(
        lib.GrB_mxv(
            out._vector[0],
            mask,
            accum,
            semiring.get_semiring(typ),
            self._matrix[0],
            other._vector[0],
            desc,
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.nonzero"><code class="name flex">
<span>def <span class="ident">nonzero</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the non-zero Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nonzero(self):
    &#34;&#34;&#34;Select the non-zero Matrix.&#34;&#34;&#34;
    return self.select(lib.GxB_NONZERO)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.offdiag"><code class="name flex">
<span>def <span class="ident">offdiag</span></span>(<span>self, thunk=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the off-diagonal Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offdiag(self, thunk=None):
    &#34;&#34;&#34;Select the off-diagonal Matrix.&#34;&#34;&#34;
    return self.select(lib.GxB_OFFDIAG, thunk=thunk)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.pattern"><code class="name flex">
<span>def <span class="ident">pattern</span></span>(<span>self, typ=pygraphblas.types.BOOL)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the pattern of the matrix where every present value in this
matrix is set to identity value for the provided type which
defaults to BOOL.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; P = M.pattern()
&gt;&gt;&gt; P.type == types.BOOL
True
&gt;&gt;&gt; P[0,1]
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pattern(self, typ=types.BOOL):
    &#34;&#34;&#34;Return the pattern of the matrix where every present value in this
    matrix is set to identity value for the provided type which
    defaults to BOOL.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; P = M.pattern()
    &gt;&gt;&gt; P.type == types.BOOL
    True
    &gt;&gt;&gt; P[0,1]
    True

    &#34;&#34;&#34;

    r = ffi.new(&#34;GrB_Matrix*&#34;)
    self._check(lib.LAGraph_pattern(r, self._matrix[0], typ.gb_type))
    return Matrix(r, typ)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.reduce_bool"><code class="name flex">
<span>def <span class="ident">reduce_bool</span></span>(<span>self, mon=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce matrix to a boolean.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_bool(self, mon=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Reduce matrix to a boolean.&#34;&#34;&#34;
    if mon is None:
        mon = current_monoid.get(types.BOOL.LOR_MONOID)
    mon = mon.get_monoid(self.type)
    result = ffi.new(&#34;_Bool*&#34;)
    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        lib.GrB_Matrix_reduce_BOOL(result, accum, mon, self._matrix[0], desc)
    )
    return result[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.reduce_float"><code class="name flex">
<span>def <span class="ident">reduce_float</span></span>(<span>self, mon=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce matrix to an float.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_float(self, mon=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Reduce matrix to an float.&#34;&#34;&#34;
    if mon is None:
        mon = current_monoid.get(self.type.PLUS_MONOID)
    mon = mon.get_monoid(self.type)
    mask, accum, desc = self._get_args(mask, accum, desc)
    result = ffi.new(&#34;double*&#34;)
    self._check(
        lib.GrB_Matrix_reduce_FP64(result, accum, mon, self._matrix[0], desc)
    )
    return result[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.reduce_int"><code class="name flex">
<span>def <span class="ident">reduce_int</span></span>(<span>self, mon=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce matrix to an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_int(self, mon=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Reduce matrix to an integer.&#34;&#34;&#34;
    if mon is None:
        mon = current_monoid.get(types.INT64.PLUS_MONOID)
    mon = mon.get_monoid(self.type)
    result = ffi.new(&#34;int64_t*&#34;)
    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        lib.GrB_Matrix_reduce_INT64(result, accum, mon, self._matrix[0], desc)
    )
    return result[0]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.reduce_vector"><code class="name flex">
<span>def <span class="ident">reduce_vector</span></span>(<span>self, mon=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce matrix to a vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_vector(self, mon=None, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Reduce matrix to a vector.&#34;&#34;&#34;
    if mon is None:
        mon = current_monoid.get(getattr(self.type, &#34;PLUS_MONOID&#34;, NULL))
    mon = mon.get_monoid(self.type)
    if out is None:
        out = Vector.sparse(self.type, self.nrows)
    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(
        lib.GrB_Matrix_reduce_Monoid(
            out._vector[0], mask, accum, mon, self._matrix[0], desc
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, nrows, ncols)</span>
</code></dt>
<dd>
<div class="desc"><p>Resize the matrix.
If the dimensions decrease, entries that fall
outside the resized matrix are deleted.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; M.shape
(3, 3)
&gt;&gt;&gt; M.resize(10, 10)
&gt;&gt;&gt; M.shape
(10, 10)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize(self, nrows, ncols):
    &#34;&#34;&#34;Resize the matrix.  If the dimensions decrease, entries that fall
    outside the resized matrix are deleted.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; M.shape
    (3, 3)
    &gt;&gt;&gt; M.resize(10, 10)
    &gt;&gt;&gt; M.shape
    (10, 10)

    &#34;&#34;&#34;
    self._check(lib.GrB_Matrix_resize(self._matrix[0], nrows, ncols))</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, op, thunk=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Select elements that match the given select operation condition.
Can be a string mapping to following operators:</p>
<pre><code>"&gt;": lib.GxB_GT_THUNK
"&lt;": lib.GxB_LT_THUNK
"&gt;=": lib.GxB_GE_THUNK
"&lt;=": lib.GxB_LE_THUNK
"!=": lib.GxB_NE_THUNK
"==": lib.GxB_EQ_THUNK
"&gt;0": lib.GxB_GT_ZERO
"&lt;0": lib.GxB_LT_ZERO
"&gt;=0": lib.GxB_GE_ZERO
"&lt;=0": lib.GxB_LE_ZERO
"!=0": lib.GxB_NONZERO
"==0": lib.GxB_EQ_ZERO
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, op, thunk=None, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Select elements that match the given select operation condition.
    Can be a string mapping to following operators:

        &#34;&gt;&#34;: lib.GxB_GT_THUNK
        &#34;&lt;&#34;: lib.GxB_LT_THUNK
        &#34;&gt;=&#34;: lib.GxB_GE_THUNK
        &#34;&lt;=&#34;: lib.GxB_LE_THUNK
        &#34;!=&#34;: lib.GxB_NE_THUNK
        &#34;==&#34;: lib.GxB_EQ_THUNK
        &#34;&gt;0&#34;: lib.GxB_GT_ZERO
        &#34;&lt;0&#34;: lib.GxB_LT_ZERO
        &#34;&gt;=0&#34;: lib.GxB_GE_ZERO
        &#34;&lt;=0&#34;: lib.GxB_LE_ZERO
        &#34;!=0&#34;: lib.GxB_NONZERO
        &#34;==0&#34;: lib.GxB_EQ_ZERO

    &#34;&#34;&#34;
    if out is None:
        out = self.__class__.sparse(self.type, self.nrows, self.ncols)
    if isinstance(op, str):
        op = _get_select_op(op)

    if thunk is None:
        thunk = NULL
    if isinstance(thunk, (bool, int, float, complex)):
        thunk = Scalar.from_value(thunk)
    if isinstance(thunk, Scalar):
        self._keep_alives[self._matrix] = thunk
        thunk = thunk.scalar[0]

    mask, accum, desc = self._get_args(mask, accum, desc)

    self._check(
        lib.GxB_Matrix_select(
            out._matrix[0], mask, accum, op, self._matrix[0], thunk, desc
        )
    )
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.to_arrays"><code class="name flex">
<span>def <span class="ident">to_arrays</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert Matrix to tuple of three dense array objects.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; M.to_arrays()
(array('L', [0, 1, 2]), array('L', [1, 2, 0]), array('q', [42, 314, 1492]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_arrays(self):
    &#34;&#34;&#34;Convert Matrix to tuple of three dense array objects.

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; M.to_arrays()
    (array(&#39;L&#39;, [0, 1, 2]), array(&#39;L&#39;, [1, 2, 0]), array(&#39;q&#39;, [42, 314, 1492]))

    &#34;&#34;&#34;
    if self.type.typecode is None:
        raise TypeError(&#34;This matrix has no array typecode.&#34;)
    nvals = self.nvals
    _nvals = ffi.new(&#34;GrB_Index[1]&#34;, [nvals])
    I = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
    J = ffi.new(&#34;GrB_Index[%s]&#34; % nvals)
    X = self.type.ffi.new(&#34;%s[%s]&#34; % (self.type.C, nvals))
    self._check(self.type.Matrix_extractTuples(I, J, X, _nvals, self._matrix[0]))
    return array(&#34;L&#34;, I), array(&#34;L&#34;, J), array(self.type.typecode, X)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.to_binfile"><code class="name flex">
<span>def <span class="ident">to_binfile</span></span>(<span>self, filename, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>Write this matrix using custom SuiteSparse binary format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_binfile(self, filename, comments=&#34;&#34;):
    &#34;&#34;&#34;Write this matrix using custom SuiteSparse binary format.&#34;&#34;&#34;
    self._check(
        lib.LAGraph_binwrite(self._matrix, filename, bytes(comments, &#34;utf8&#34;))
    )</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.to_lists"><code class="name flex">
<span>def <span class="ident">to_lists</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the rows, columns and values of the Matrix as 3 lists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_lists(self):
    &#34;&#34;&#34;Extract the rows, columns and values of the Matrix as 3 lists.&#34;&#34;&#34;
    I = ffi.new(&#34;GrB_Index[%s]&#34; % self.nvals)
    J = ffi.new(&#34;GrB_Index[%s]&#34; % self.nvals)
    V = self.type.ffi.new(self.type.C + &#34;[%s]&#34; % self.nvals)
    n = ffi.new(&#34;GrB_Index*&#34;)
    n[0] = self.nvals
    self._check(self.type.Matrix_extractTuples(I, J, V, n, self._matrix[0]))
    return [list(I), list(J), list(map(self.type.to_value, V))]</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.to_mm"><code class="name flex">
<span>def <span class="ident">to_mm</span></span>(<span>self, fileobj)</span>
</code></dt>
<dd>
<div class="desc"><p>Write this matrix to a file using the Matrix Market format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_mm(self, fileobj):
    &#34;&#34;&#34;Write this matrix to a file using the Matrix Market format.&#34;&#34;&#34;
    self._check(lib.LAGraph_mmwrite(self._matrix[0], fileobj))</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.to_numpy"><code class="name flex">
<span>def <span class="ident">to_numpy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dense numpy matrix of this Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy(self):
    &#34;&#34;&#34;Return a dense numpy matrix of this Matrix.&#34;&#34;&#34;
    s = self.to_scipy_sparse(&#34;coo&#34;)
    return s.toarray()</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.to_scipy_sparse"><code class="name flex">
<span>def <span class="ident">to_scipy_sparse</span></span>(<span>self, format='csr')</span>
</code></dt>
<dd>
<div class="desc"><p>Return a scipy sparse matrix of this Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_scipy_sparse(self, format=&#34;csr&#34;):
    &#34;&#34;&#34;Return a scipy sparse matrix of this Matrix.&#34;&#34;&#34;
    from scipy import sparse

    rows, cols, vals = self.to_arrays()
    s = sparse.coo_matrix((vals, (rows, cols)), shape=self.shape)
    if format == &#34;coo&#34;:
        return s
    if format not in {&#34;bsr&#34;, &#34;csr&#34;, &#34;csc&#34;, &#34;coo&#34;, &#34;lil&#34;, &#34;dia&#34;, &#34;dok&#34;}:
        raise Exception(f&#34;Invalid format: {format}&#34;)
    return s.asformat(format)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self, format_string=&#x27;{:&gt;%s}&#x27;, width=3, empty_char='')</span>
</code></dt>
<dd>
<div class="desc"><p>Return a string representation of the Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(self, format_string=&#34;{:&gt;%s}&#34;, width=3, empty_char=&#34;&#34;):
    &#34;&#34;&#34;Return a string representation of the Matrix.&#34;&#34;&#34;
    format_string = format_string % width
    header = (
        format_string.format(&#34;&#34;)
        + &#34; &#34;
        + &#34;&#34;.join(format_string.format(i) for i in range(self.ncols))
    )
    result = header + &#34;\n&#34;
    for row in range(self.nrows):
        result += format_string.format(row) + &#34;|&#34;
        for col in range(self.ncols):
            value = self.get(row, col, empty_char)
            result += self.type.format_value(value, width)
        result += &#34;|&#34; + format_string.format(row) + &#34;\n&#34;
    result += header

    return result</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.transpose"><code class="name flex">
<span>def <span class="ident">transpose</span></span>(<span>self, cast=None, out=None, mask=None, accum=None, desc=&lt;Descriptor Default&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Return Transpose of this matrix.</p>
<p>This function can serve multiple interesting purposes
including typecasting.
See the <a href="https://raw.githubusercontent.com/DrTimothyAldenDavis/GraphBLAS/stable/Doc/GraphBLAS_UserGuide.pdf">SuiteSparse User
Guide</a></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
&gt;&gt;&gt; MT = M.transpose()
&gt;&gt;&gt; MT.to_lists()
[[0, 1, 2], [2, 0, 1], [1492, 42, 314]]
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; MT = M.transpose(cast=types.BOOL, desc=descriptor.T0)
&gt;&gt;&gt; MT.to_lists()
[[0, 1, 2], [1, 2, 0], [True, True, True]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpose(self, cast=None, out=None, mask=None, accum=None, desc=Default):
    &#34;&#34;&#34;Return Transpose of this matrix.

    This function can serve multiple interesting purposes
    including typecasting.  See the [SuiteSparse User
    Guide](https://raw.githubusercontent.com/DrTimothyAldenDavis/GraphBLAS/stable/Doc/GraphBLAS_UserGuide.pdf)

    &gt;&gt;&gt; M = Matrix.from_lists([0, 1, 2], [1, 2, 0], [42, 314, 1492])
    &gt;&gt;&gt; MT = M.transpose()
    &gt;&gt;&gt; MT.to_lists()
    [[0, 1, 2], [2, 0, 1], [1492, 42, 314]]

    &gt;&gt;&gt; MT = M.transpose(cast=types.BOOL, desc=descriptor.T0)
    &gt;&gt;&gt; MT.to_lists()
    [[0, 1, 2], [1, 2, 0], [True, True, True]]

    &#34;&#34;&#34;
    if out is None:
        new_dimensions = (
            (self.nrows, self.ncols)
            if TransposeA in desc
            else (self.ncols, self.nrows)
        )
        _out = ffi.new(&#34;GrB_Matrix*&#34;)
        if cast is not None:
            typ = cast
        else:
            typ = self.type
        self._check(lib.GrB_Matrix_new(_out, typ.gb_type, *new_dimensions))
        out = self.__class__(_out, typ)
    mask, accum, desc = self._get_args(mask, accum, desc)
    self._check(lib.GrB_transpose(out._matrix[0], mask, accum, self._matrix[0], desc))
    return out</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.tril"><code class="name flex">
<span>def <span class="ident">tril</span></span>(<span>self, thunk=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the lower triangular Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tril(self, thunk=None):
    &#34;&#34;&#34;Select the lower triangular Matrix.&#34;&#34;&#34;
    return self.select(lib.GxB_TRIL, thunk=thunk)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.triu"><code class="name flex">
<span>def <span class="ident">triu</span></span>(<span>self, thunk=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the upper triangular Matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triu(self, thunk=None):
    &#34;&#34;&#34;Select the upper triangular Matrix.&#34;&#34;&#34;
    return self.select(lib.GxB_TRIU, thunk=thunk)</code></pre>
</details>
</dd>
<dt id="pygraphblas.matrix.Matrix.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for this Matrix to complete before allowing another thread to
change it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self):
    &#34;&#34;&#34;Wait for this Matrix to complete before allowing another thread to
    change it.

    &#34;&#34;&#34;
    self._check(lib.GrB_Matrix_wait(self._matrix))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygraphblas" href="index.html">pygraphblas</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Types</a></h3>
<ul>
<li>
<code><a title="pygraphblas.matrix.Matrix" href="#pygraphblas.matrix.Matrix">Matrix</a></code>
<ul class="two-column">
<li><code><a title="pygraphblas.matrix.Matrix.T" href="#pygraphblas.matrix.Matrix.T">T</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.apply" href="#pygraphblas.matrix.Matrix.apply">apply</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.apply_first" href="#pygraphblas.matrix.Matrix.apply_first">apply_first</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.apply_second" href="#pygraphblas.matrix.Matrix.apply_second">apply_second</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.assign_col" href="#pygraphblas.matrix.Matrix.assign_col">assign_col</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.assign_matrix" href="#pygraphblas.matrix.Matrix.assign_matrix">assign_matrix</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.assign_row" href="#pygraphblas.matrix.Matrix.assign_row">assign_row</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.assign_scalar" href="#pygraphblas.matrix.Matrix.assign_scalar">assign_scalar</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.cast" href="#pygraphblas.matrix.Matrix.cast">cast</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.clear" href="#pygraphblas.matrix.Matrix.clear">clear</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.cols" href="#pygraphblas.matrix.Matrix.cols">cols</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.dense" href="#pygraphblas.matrix.Matrix.dense">dense</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.diag" href="#pygraphblas.matrix.Matrix.diag">diag</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.dup" href="#pygraphblas.matrix.Matrix.dup">dup</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.eadd" href="#pygraphblas.matrix.Matrix.eadd">eadd</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.emult" href="#pygraphblas.matrix.Matrix.emult">emult</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.extract_col" href="#pygraphblas.matrix.Matrix.extract_col">extract_col</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.extract_matrix" href="#pygraphblas.matrix.Matrix.extract_matrix">extract_matrix</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.extract_row" href="#pygraphblas.matrix.Matrix.extract_row">extract_row</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.format" href="#pygraphblas.matrix.Matrix.format">format</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.from_binfile" href="#pygraphblas.matrix.Matrix.from_binfile">from_binfile</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.from_lists" href="#pygraphblas.matrix.Matrix.from_lists">from_lists</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.from_mm" href="#pygraphblas.matrix.Matrix.from_mm">from_mm</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.from_tsv" href="#pygraphblas.matrix.Matrix.from_tsv">from_tsv</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.gb_type" href="#pygraphblas.matrix.Matrix.gb_type">gb_type</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.get" href="#pygraphblas.matrix.Matrix.get">get</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.hyper_switch" href="#pygraphblas.matrix.Matrix.hyper_switch">hyper_switch</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.identity" href="#pygraphblas.matrix.Matrix.identity">identity</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.iseq" href="#pygraphblas.matrix.Matrix.iseq">iseq</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.isne" href="#pygraphblas.matrix.Matrix.isne">isne</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.kronecker" href="#pygraphblas.matrix.Matrix.kronecker">kronecker</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.mxm" href="#pygraphblas.matrix.Matrix.mxm">mxm</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.mxv" href="#pygraphblas.matrix.Matrix.mxv">mxv</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.ncols" href="#pygraphblas.matrix.Matrix.ncols">ncols</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.nonzero" href="#pygraphblas.matrix.Matrix.nonzero">nonzero</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.nrows" href="#pygraphblas.matrix.Matrix.nrows">nrows</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.nvals" href="#pygraphblas.matrix.Matrix.nvals">nvals</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.offdiag" href="#pygraphblas.matrix.Matrix.offdiag">offdiag</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.pattern" href="#pygraphblas.matrix.Matrix.pattern">pattern</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.random" href="#pygraphblas.matrix.Matrix.random">random</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.reduce_bool" href="#pygraphblas.matrix.Matrix.reduce_bool">reduce_bool</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.reduce_float" href="#pygraphblas.matrix.Matrix.reduce_float">reduce_float</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.reduce_int" href="#pygraphblas.matrix.Matrix.reduce_int">reduce_int</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.reduce_vector" href="#pygraphblas.matrix.Matrix.reduce_vector">reduce_vector</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.resize" href="#pygraphblas.matrix.Matrix.resize">resize</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.rows" href="#pygraphblas.matrix.Matrix.rows">rows</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.select" href="#pygraphblas.matrix.Matrix.select">select</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.shape" href="#pygraphblas.matrix.Matrix.shape">shape</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.sparse" href="#pygraphblas.matrix.Matrix.sparse">sparse</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.sparsity_control" href="#pygraphblas.matrix.Matrix.sparsity_control">sparsity_control</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.sparsity_status" href="#pygraphblas.matrix.Matrix.sparsity_status">sparsity_status</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.square" href="#pygraphblas.matrix.Matrix.square">square</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.to_arrays" href="#pygraphblas.matrix.Matrix.to_arrays">to_arrays</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.to_binfile" href="#pygraphblas.matrix.Matrix.to_binfile">to_binfile</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.to_lists" href="#pygraphblas.matrix.Matrix.to_lists">to_lists</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.to_mm" href="#pygraphblas.matrix.Matrix.to_mm">to_mm</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.to_numpy" href="#pygraphblas.matrix.Matrix.to_numpy">to_numpy</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.to_scipy_sparse" href="#pygraphblas.matrix.Matrix.to_scipy_sparse">to_scipy_sparse</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.to_string" href="#pygraphblas.matrix.Matrix.to_string">to_string</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.transpose" href="#pygraphblas.matrix.Matrix.transpose">transpose</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.tril" href="#pygraphblas.matrix.Matrix.tril">tril</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.triu" href="#pygraphblas.matrix.Matrix.triu">triu</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.type" href="#pygraphblas.matrix.Matrix.type">type</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.vals" href="#pygraphblas.matrix.Matrix.vals">vals</a></code></li>
<li><code><a title="pygraphblas.matrix.Matrix.wait" href="#pygraphblas.matrix.Matrix.wait">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<h4>Copyright &copy; 2021 Graphegon, Inc. Author: Michel Pelletier with
some content from Tim Davis's GraphBLAS User Guide.</h4>
<h4>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</h4>
</footer>
</body>
</html>